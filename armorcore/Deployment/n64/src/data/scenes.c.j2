#include <libdragon.h>
#include <t3d/t3d.h>
#include <t3d/t3dmodel.h>
#include <string.h>

#include "../types.h"
#include "../engine.h"
#include "scenes.h"

#if ENGINE_ENABLE_PHYSICS
#include "../physics.h"
#endif

static ArmScene g_scenes[SCENE_COUNT];
static SceneId g_pending_scene = SCENE_COUNT;

void scene_init(SceneId id)
{{
    if (id >= SCENE_COUNT) return;

    switch (id) {{
{scene_init_switch_cases}
		default: break;
    }}
	scene_on_ready(id);
}}

void scene_on_ready(SceneId id)
{{
	ArmScene *s = &g_scenes[id];

	for (uint8_t i = 0; i < s->trait_count; i++) {{
		if (s->traits[i].on_ready) s->traits[i].on_ready(s, s->traits[i].data);
	}}
	if (s->cameras) {{
		for (uint8_t i = 0; i < s->camera_count; i++) {{
			for (uint8_t t = 0; t < s->cameras[i].trait_count; t++) {{
				if (s->cameras[i].traits[t].on_ready) s->cameras[i].traits[t].on_ready(&s->cameras[i], s->cameras[i].traits[t].data);
			}}
		}}
	}}
	if (s->lights) {{
		for (uint8_t i = 0; i < s->light_count; i++) {{
			for (uint8_t t = 0; t < s->lights[i].trait_count; t++) {{
				if (s->lights[i].traits[t].on_ready) s->lights[i].traits[t].on_ready(&s->lights[i], s->lights[i].traits[t].data);
			}}
		}}
	}}
	if (s->objects) {{
		for (uint16_t i = 0; i < s->object_count; i++) {{
			for (uint8_t t = 0; t < s->objects[i].trait_count; t++) {{
				if (s->objects[i].traits[t].on_ready) s->objects[i].traits[t].on_ready(&s->objects[i], s->objects[i].traits[t].data);
			}}
		}}
	}}
}}

void scene_on_fixed_update(SceneId id, float dt)
{{
	ArmScene *s = &g_scenes[id];

	for (uint8_t i = 0; i < s->trait_count; i++) {{
		if (s->traits[i].on_fixed_update) s->traits[i].on_fixed_update(s, dt, s->traits[i].data);
	}}
	if (s->cameras) {{
		for (uint8_t i = 0; i < s->camera_count; i++) {{
			for (uint8_t t = 0; t < s->cameras[i].trait_count; t++) {{
				if (s->cameras[i].traits[t].on_fixed_update) s->cameras[i].traits[t].on_fixed_update(&s->cameras[i], dt, s->cameras[i].traits[t].data);
			}}
		}}
	}}
	if (s->lights) {{
		for (uint8_t i = 0; i < s->light_count; i++) {{
			for (uint8_t t = 0; t < s->lights[i].trait_count; t++) {{
				if (s->lights[i].traits[t].on_fixed_update) s->lights[i].traits[t].on_fixed_update(&s->lights[i], dt, s->lights[i].traits[t].data);
			}}
		}}
	}}
	if (s->objects) {{
		for (uint16_t i = 0; i < s->object_count; i++) {{
			for (uint8_t t = 0; t < s->objects[i].trait_count; t++) {{
				if (s->objects[i].traits[t].on_fixed_update) s->objects[i].traits[t].on_fixed_update(&s->objects[i], dt, s->objects[i].traits[t].data);
			}}
		}}
	}}
}}

void scene_sync_physics(SceneId id)
{{
#if ENGINE_ENABLE_PHYSICS
	ArmScene *s = &g_scenes[id];
	if (s->objects) {{
		for (uint16_t i = 0; i < s->object_count; i++) {{
			physics_sync_object(&s->objects[i]);
		}}
	}}
#else
	(void)id;
#endif
}}

void scene_on_update(SceneId id, float dt)
{{
	ArmScene *s = &g_scenes[id];

	for (uint8_t i = 0; i < s->trait_count; i++) {{
		if (s->traits[i].on_update) s->traits[i].on_update(s, dt, s->traits[i].data);
	}}
	if (s->cameras) {{
		for (uint8_t i = 0; i < s->camera_count; i++) {{
			for (uint8_t t = 0; t < s->cameras[i].trait_count; t++) {{
				if (s->cameras[i].traits[t].on_update) s->cameras[i].traits[t].on_update(&s->cameras[i], dt, s->cameras[i].traits[t].data);
			}}
		}}
	}}
	if (s->lights) {{
		for (uint8_t i = 0; i < s->light_count; i++) {{
			for (uint8_t t = 0; t < s->lights[i].trait_count; t++) {{
				if (s->lights[i].traits[t].on_update) s->lights[i].traits[t].on_update(&s->lights[i], dt, s->lights[i].traits[t].data);
			}}
		}}
	}}
	if (s->objects) {{
		for (uint16_t i = 0; i < s->object_count; i++) {{
			for (uint8_t t = 0; t < s->objects[i].trait_count; t++) {{
				if (s->objects[i].traits[t].on_update) s->objects[i].traits[t].on_update(&s->objects[i], dt, s->objects[i].traits[t].data);
			}}
		}}
	}}
}}

void scene_on_late_update(SceneId id, float dt)
{{
	ArmScene *s = &g_scenes[id];

	for (uint8_t i = 0; i < s->trait_count; i++) {{
		if (s->traits[i].on_late_update) s->traits[i].on_late_update(s, dt, s->traits[i].data);
	}}
	if (s->cameras) {{
		for (uint8_t i = 0; i < s->camera_count; i++) {{
			for (uint8_t t = 0; t < s->cameras[i].trait_count; t++) {{
				if (s->cameras[i].traits[t].on_late_update) s->cameras[i].traits[t].on_late_update(&s->cameras[i], dt, s->cameras[i].traits[t].data);
			}}
		}}
	}}
	if (s->lights) {{
		for (uint8_t i = 0; i < s->light_count; i++) {{
			for (uint8_t t = 0; t < s->lights[i].trait_count; t++) {{
				if (s->lights[i].traits[t].on_late_update) s->lights[i].traits[t].on_late_update(&s->lights[i], dt, s->lights[i].traits[t].data);
			}}
		}}
	}}
	if (s->objects) {{
		for (uint16_t i = 0; i < s->object_count; i++) {{
			for (uint8_t t = 0; t < s->objects[i].trait_count; t++) {{
				if (s->objects[i].traits[t].on_late_update) s->objects[i].traits[t].on_late_update(&s->objects[i], dt, s->objects[i].traits[t].data);
			}}
		}}
	}}
}}

void scene_on_remove(SceneId id)
{{
	ArmScene *s = &g_scenes[id];

	for (uint8_t i = 0; i < s->trait_count; i++) {{
		if (s->traits[i].on_remove) s->traits[i].on_remove(s, s->traits[i].data);
	}}
	if (s->cameras) {{
		for (uint8_t i = 0; i < s->camera_count; i++) {{
			for (uint8_t t = 0; t < s->cameras[i].trait_count; t++) {{
				if (s->cameras[i].traits[t].on_remove) s->cameras[i].traits[t].on_remove(&s->cameras[i], s->cameras[i].traits[t].data);
			}}
		}}
	}}
	if (s->lights) {{
		for (uint8_t i = 0; i < s->light_count; i++) {{
			for (uint8_t t = 0; t < s->lights[i].trait_count; t++) {{
				if (s->lights[i].traits[t].on_remove) s->lights[i].traits[t].on_remove(&s->lights[i], s->lights[i].traits[t].data);
			}}
		}}
	}}
	if (s->objects) {{
		for (uint16_t i = 0; i < s->object_count; i++) {{
			for (uint8_t t = 0; t < s->objects[i].trait_count; t++) {{
				if (s->objects[i].traits[t].on_remove) s->objects[i].traits[t].on_remove(&s->objects[i], s->objects[i].traits[t].data);
			}}
		}}
	}}
}}

void scene_clear(SceneId id)
{{
    if (id >= SCENE_COUNT) return;

    ArmScene *s = &g_scenes[id];
    scene_on_remove(id);

    // Free object resources
    if (s->objects != NULL) {{
        for (uint16_t i = 0; i < s->object_count; i++) {{
#if ENGINE_ENABLE_PHYSICS
            if (s->objects[i].rigid_body) physics_remove_body(&s->objects[i]);
#endif
            if (s->objects[i].model_mat) {{ free_uncached(s->objects[i].model_mat); s->objects[i].model_mat = NULL; }}
            // Free trait data (malloc'd) before freeing traits array
            if (s->objects[i].traits) {{
                for (uint8_t t = 0; t < s->objects[i].trait_count; t++) {{
                    if (s->objects[i].traits[t].data) {{ free(s->objects[i].traits[t].data); s->objects[i].traits[t].data = NULL; }}
                }}
                free(s->objects[i].traits);
                s->objects[i].traits = NULL;
            }}
            s->objects[i].dpl = NULL;
            s->objects[i].trait_count = 0;
        }}
    }}

    // Free camera trait data
    if (s->cameras != NULL) {{
        for (uint8_t i = 0; i < s->camera_count; i++) {{
            if (s->cameras[i].traits) {{
                for (uint8_t t = 0; t < s->cameras[i].trait_count; t++) {{
                    if (s->cameras[i].traits[t].data) {{ free(s->cameras[i].traits[t].data); s->cameras[i].traits[t].data = NULL; }}
                }}
                free(s->cameras[i].traits);
                s->cameras[i].traits = NULL;
            }}
            s->cameras[i].trait_count = 0;
        }}
    }}

    // Free light trait data
    if (s->lights != NULL) {{
        for (uint8_t i = 0; i < s->light_count; i++) {{
            if (s->lights[i].traits) {{
                for (uint8_t t = 0; t < s->lights[i].trait_count; t++) {{
                    if (s->lights[i].traits[t].data) {{ free(s->lights[i].traits[t].data); s->lights[i].traits[t].data = NULL; }}
                }}
                free(s->lights[i].traits);
                s->lights[i].traits = NULL;
            }}
            s->lights[i].trait_count = 0;
        }}
    }}

    // Free scene-level trait data (note: scene_traits array itself is static, don't free it)
    if (s->traits != NULL) {{
        for (uint8_t i = 0; i < s->trait_count; i++) {{
            if (s->traits[i].data) {{ free(s->traits[i].data); s->traits[i].data = NULL; }}
        }}
        // Don't free s->traits - it's a static array
        s->traits = NULL;
    }}

	s->world.clear_color[0] = s->world.clear_color[1] = s->world.clear_color[2] = 0;
	s->world.clear_color[3] = 0xFF;
	s->world.ambient_color[0] = s->world.ambient_color[1] = s->world.ambient_color[2] = 0;
	s->world.ambient_color[3] = 0xFF;
	s->cameras = NULL;
	s->camera_count = 0;
	s->active_camera_id = 0;
	s->lights = NULL;
	s->light_count = 0;
	s->objects = NULL;
	s->object_count = 0;
    s->trait_count = 0;
}}

ArmScene *scene_get(SceneId id)
{{
    if (id >= SCENE_COUNT) return NULL;
    return &g_scenes[id];
}}

// Scene name to ID lookup table
static const struct {{ const char *name; SceneId id; }} g_scene_names[] = {{
{scene_name_entries}
}};

SceneId scene_get_id_by_name(const char *name)
{{
    if (name == NULL) return SCENE_COUNT;
    for (int i = 0; i < {scene_count}; i++) {{
        if (strcmp(g_scene_names[i].name, name) == 0) {{
            return g_scene_names[i].id;
        }}
    }}
    return SCENE_COUNT; // Not found
}}

SceneId scene_get_pending(void) {{ return g_pending_scene; }}
void scene_switch_to(SceneId id) {{ g_pending_scene = id; }}
void scene_clear_pending(void) {{ g_pending_scene = SCENE_COUNT; }}
