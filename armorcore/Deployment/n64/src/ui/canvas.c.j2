#include "canvas.h"
#include "fonts.h"
#include <libdragon.h>
#include <string.h>

#if UI_LABEL_COUNT > 0

// ============================================================================
// Label pool and render list
// ============================================================================

// Static label pool - avoids malloc() in hot paths
static UILabel g_label_pool[UI_MAX_LABELS];
static uint8_t g_label_pool_used = 0;

// Render list - pointers to labels that should be rendered
static UILabel* g_render_list[UI_MAX_LABELS];
static uint8_t g_render_count = 0;

// Default font ID for rendering
static uint8_t g_default_font_rdpq_id = 0;
static bool g_initialized = false;

// Canvas label tracking (for get_label by index)
static UILabel* g_canvas_labels[UI_LABEL_COUNT];
static int g_canvas_label_count = 0;

// ============================================================================
// Label definition struct and anchor calculations
// ============================================================================

typedef struct {{
    const char *text;
    int16_t pos_x;
    int16_t pos_y;
    int16_t width;
    int16_t height;
    uint8_t anchor;
    bool visible;
}} UILabelDef;

// Calculate final X position based on anchor
static int16_t calc_anchor_x(const UILabelDef *def) {{
    switch (def->anchor) {{
        case UI_ANCHOR_TOP_LEFT:
        case UI_ANCHOR_MIDDLE_LEFT:
        case UI_ANCHOR_BOTTOM_LEFT:
            return def->pos_x;
        case UI_ANCHOR_TOP_CENTER:
        case UI_ANCHOR_MIDDLE_CENTER:
        case UI_ANCHOR_BOTTOM_CENTER:
            return (CANVAS_WIDTH / 2) - (def->width / 2) + def->pos_x;
        case UI_ANCHOR_TOP_RIGHT:
        case UI_ANCHOR_MIDDLE_RIGHT:
        case UI_ANCHOR_BOTTOM_RIGHT:
            return CANVAS_WIDTH - def->width + def->pos_x;
        default:
            return def->pos_x;
    }}
}}

// Calculate final Y position based on anchor
static int16_t calc_anchor_y(const UILabelDef *def) {{
    switch (def->anchor) {{
        case UI_ANCHOR_TOP_LEFT:
        case UI_ANCHOR_TOP_CENTER:
        case UI_ANCHOR_TOP_RIGHT:
            return def->pos_y;
        case UI_ANCHOR_MIDDLE_LEFT:
        case UI_ANCHOR_MIDDLE_CENTER:
        case UI_ANCHOR_MIDDLE_RIGHT:
            return (CANVAS_HEIGHT / 2) - (def->height / 2) + def->pos_y;
        case UI_ANCHOR_BOTTOM_LEFT:
        case UI_ANCHOR_BOTTOM_CENTER:
        case UI_ANCHOR_BOTTOM_RIGHT:
            return CANVAS_HEIGHT - def->height + def->pos_y;
        default:
            return def->pos_y;
    }}
}}

// Per-canvas label data arrays (generated from Koui Editor JSON)
{canvas_label_arrays}

// Helper to load labels from a definition array
static void load_labels(const UILabelDef *defs, int count) {{
    for (int i = 0; i < count; i++) {{
        const UILabelDef *def = &defs[i];
        UILabel *label = ui_label_create(def->text);
        if (label) {{
            int16_t final_x = calc_anchor_x(def);
            int16_t final_y = calc_anchor_y(def);
            ui_label_set_position(label, final_x, final_y);
            label->visible = def->visible;
            ui_label_add(label);
            g_canvas_labels[g_canvas_label_count++] = label;
        }}
    }}
}}

// ============================================================================
// Public API
// ============================================================================

void canvas_init(void)
{{
    if (g_initialized) return;
    g_initialized = true;

    g_label_pool_used = 0;
    g_render_count = 0;
    g_canvas_label_count = 0;
    memset(g_label_pool, 0, sizeof(g_label_pool));
    memset(g_render_list, 0, sizeof(g_render_list));
    memset(g_canvas_labels, 0, sizeof(g_canvas_labels));

    // Get the first font (index 0) as default for UI labels
    rdpq_font_t *font = fonts_get(0);
    if (font) {{
        g_default_font_rdpq_id = fonts_get_rdpq_id(0);
        // Set default style 0 to white
        rdpq_font_style(font, 0, &(rdpq_fontstyle_t){{
            .color = RGBA32(255, 255, 255, 255)
        }});
    }}
}}

void canvas_scene_init(SceneId scene_id) {{
    // Clear previous scene's labels first
    canvas_clear();

    // Load canvas for the specified scene
    switch (scene_id) {{
{scene_init_switch_cases}
        default:
            break;
    }}
}}

void canvas_clear(void)
{{
    // Reset label pool and render list (call on scene change)
    g_label_pool_used = 0;
    g_render_count = 0;
    g_canvas_label_count = 0;
    memset(g_label_pool, 0, sizeof(g_label_pool));
    memset(g_render_list, 0, sizeof(g_render_list));
    memset(g_canvas_labels, 0, sizeof(g_canvas_labels));
}}

UILabel* ui_label_create(const char *text)
{{
    // Allocate from static pool - no malloc!
    if (g_label_pool_used >= UI_MAX_LABELS) return NULL;
    UILabel *label = &g_label_pool[g_label_pool_used++];

    // Copy text into label's own buffer
    if (text) {{
        strncpy(label->text, text, UI_LABEL_TEXT_SIZE - 1);
        label->text[UI_LABEL_TEXT_SIZE - 1] = '\0';
    }} else {{
        label->text[0] = '\0';
    }}
    label->pos_x = 0;
    label->pos_y = 0;
    label->baseline_offset = 12;  // Default baseline offset for typical font sizes
    label->font_id = g_default_font_rdpq_id;
    label->visible = true;

    return label;
}}

void ui_label_add(UILabel *label)
{{
    if (!label || g_render_count >= UI_MAX_LABELS) return;

    // Check if already in render list
    for (uint8_t i = 0; i < g_render_count; i++) {{
        if (g_render_list[i] == label) return;
    }}

    g_render_list[g_render_count++] = label;
}}

void ui_label_remove(UILabel *label)
{{
    if (!label) return;

    // Find in render list and swap-and-pop (O(1) removal)
    for (uint8_t i = 0; i < g_render_count; i++) {{
        if (g_render_list[i] == label) {{
            // Swap with last element and decrement count
            g_render_list[i] = g_render_list[g_render_count - 1];
            g_render_count--;
            break;
        }}
    }}

    // Note: Label stays in pool until scene reset (no free needed)
}}

void ui_label_set_position(UILabel *label, int16_t x, int16_t y)
{{
    if (label) {{
        label->pos_x = x;
        label->pos_y = y;
    }}
}}

void ui_label_set_text(UILabel *label, const char *text)
{{
    if (label && text) {{
        strncpy(label->text, text, UI_LABEL_TEXT_SIZE - 1);
        label->text[UI_LABEL_TEXT_SIZE - 1] = '\0';
    }}
}}

UILabel* canvas_get_label(int index) {{
    if (index >= 0 && index < g_canvas_label_count) {{
        return g_canvas_labels[index];
    }}
    return NULL;
}}

void canvas_render(void)
{{
    // Early exit if nothing to render
    if (g_render_count == 0 || g_default_font_rdpq_id == 0) return;

    // Sync pipeline before switching from 3D to 2D mode
    rdpq_sync_pipe();

    // Begin 2D text rendering mode
    rdpq_set_mode_standard();
    rdpq_mode_combiner(RDPQ_COMBINER_TEX_FLAT);
    rdpq_mode_blender(RDPQ_BLENDER_MULTIPLY);

    // Render all visible labels in render list
    for (uint8_t i = 0; i < g_render_count; i++) {{
        UILabel *label = g_render_list[i];
        if (!label || !label->visible) continue;

        rdpq_text_print(NULL, label->font_id, label->pos_x, label->pos_y + label->baseline_offset, label->text);
    }}
}}

#endif // UI_LABEL_COUNT > 0
