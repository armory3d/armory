#include <libdragon.h>
#include <t3d/t3d.h>
#include <t3d/t3dmodel.h>

#include "types.h"
#include "scenes.h"
#include "cameras.h"
#include "lights.h"
#include "objects.h"

static ArmScene g_scenes[SCENE_COUNT];
static SceneId g_pending_scene = SCENE_COUNT;  // SCENE_COUNT = no pending

void scene_init(SceneId id)
{{
    if (id >= SCENE_COUNT) {{
        return;
    }}

    switch (id) {{
{scene_init_switch_cases}
		default:
			break;
    }}

	scene_on_ready(id);
}}

void scene_on_ready(SceneId id)
{{
	ArmScene *s = &g_scenes[id];

	// Scene-level traits
	for (uint8_t i = 0; i < s->trait_count; i++) {{
		if (s->traits[i].on_ready) {{
			s->traits[i].on_ready(s);
		}}
	}}

	for (uint8_t i = 0; i < s->camera_count; i++) {{
		if (s->cameras[i].trait_count > 0) {{
			camera_on_ready(&s->cameras[i]);
		}}
	}}

	for (uint8_t i = 0; i < s->light_count; i++) {{
		if (s->lights[i].trait_count > 0) {{
			light_on_ready(&s->lights[i]);
		}}
	}}

	for (uint16_t i = 0; i < s->object_count; i++) {{
		if (s->objects[i].trait_count > 0) {{
			object_on_ready(&s->objects[i]);
		}}
	}}
}}

void scene_on_update(SceneId id, float dt)
{{
	ArmScene *s = &g_scenes[id];

	// Scene-level traits
	for (uint8_t i = 0; i < s->trait_count; i++) {{
		if (s->traits[i].on_update) {{
			s->traits[i].on_update(s, dt);
		}}
	}}

	for (uint8_t i = 0; i < s->camera_count; i++) {{
		if (s->cameras[i].trait_count > 0) {{
			camera_on_update(&s->cameras[i], dt);
		}}
	}}

	for (uint8_t i = 0; i < s->light_count; i++) {{
		if (s->lights[i].trait_count > 0) {{
			light_on_update(&s->lights[i], dt);
		}}
	}}

	for (uint16_t i = 0; i < s->object_count; i++) {{
		if (s->objects[i].trait_count > 0) {{
			object_on_update(&s->objects[i], dt);
		}}
	}}
}}

void scene_on_remove(SceneId id)
{{
	ArmScene *s = &g_scenes[id];

	// Scene-level traits
	for (uint8_t i = 0; i < s->trait_count; i++) {{
		if (s->traits[i].on_remove) {{
			s->traits[i].on_remove(s);
		}}
	}}

	for (uint8_t i = 0; i < s->camera_count; i++) {{
		if (s->cameras[i].trait_count > 0) {{
			camera_on_remove(&s->cameras[i]);
		}}
	}}

	for (uint8_t i = 0; i < s->light_count; i++) {{
		if (s->lights[i].trait_count > 0) {{
			light_on_remove(&s->lights[i]);
		}}
	}}

	for (uint16_t i = 0; i < s->object_count; i++) {{
		if (s->objects[i].trait_count > 0) {{
			object_on_remove(&s->objects[i]);
		}}
	}}
}}

void scene_clear(SceneId id)
{{
    if (id >= SCENE_COUNT) {{
        return;
    }}

    ArmScene *s = &g_scenes[id];

    if (s->objects != NULL) {{
        scene_on_remove(id);
    }}

	for (uint16_t i = 0; i < s->object_count; i++) {{
		if (s->objects[i].model_mat) {{
			free_uncached(s->objects[i].model_mat);
			s->objects[i].model_mat = NULL;
		}}
		s->objects[i].dpl = NULL;
	}}

	s->world.clear_color[0] = s->world.clear_color[1] = s->world.clear_color[2] = 0;
	s->world.clear_color[3] = 0xFF;
	s->world.ambient_color[0] = s->world.ambient_color[1] = s->world.ambient_color[2] = 0;
	s->world.ambient_color[3] = 0xFF;

	s->cameras = NULL;
	s->camera_count = 0;
	s->active_camera_id = 0;

	s->lights = NULL;
	s->light_count = 0;
	s->objects = NULL;
	s->object_count = 0;
}}

ArmScene *scene_get(SceneId id)
{{
    if (id >= SCENE_COUNT) {{
        return NULL;
    }}
    return &g_scenes[id];
}}

SceneId scene_get_pending(void)
{{
    return g_pending_scene;
}}

void scene_switch_to(SceneId id)
{{
    g_pending_scene = id;
}}

void scene_clear_pending(void)
{{
    g_pending_scene = SCENE_COUNT;
}}
