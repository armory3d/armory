"""
N64 Coordinate Converter

Applies coordinate system conversion rules from macro-generated JSON.

Pipeline:
  1. Exporter outputs raw Blender coordinates to scene_data dict
  2. This converter applies rules from n64_traits.json
  3. Scene C writer receives already-converted values
"""

import os
import json
import math
import arm.utils


_coord_config = None


def _load_coord_config():
    """Load coordinate config from n64_traits.json (generated by Haxe macro)."""
    global _coord_config
    if _coord_config is not None:
        return _coord_config

    json_path = os.path.join(arm.utils.build_dir(), 'n64_traits.json')
    if os.path.exists(json_path):
        with open(json_path, 'r') as f:
            data = json.load(f)
            _coord_config = data.get('coordinate_system')

    # Fallback to defaults if JSON doesn't have coordinate_system yet
    # (e.g., old JSON from before macro update)
    if not _coord_config:
        _coord_config = {
            "position": {"out_x": "x", "out_y": "z", "out_z": "-y"},
            "scale": {"out_x": "x", "out_y": "z", "out_z": "y", "factor": 0.015},
            "direction": {"out_x": "x", "out_y": "z", "out_z": "-y"},
            "euler": {"out_x": "-x", "out_y": "-z", "out_z": "y"}
        }

    return _coord_config


def _apply_swizzle(vec, config):
    """Apply coordinate swizzle based on config rules. Pure mechanical operation."""
    x, y, z = vec[0], vec[1], vec[2]
    mapping = {'x': x, 'y': y, 'z': z, '-x': -x, '-y': -y, '-z': -z}
    return [
        mapping[config['out_x']],
        mapping[config['out_y']],
        mapping[config['out_z']]
    ]


def _normalize(vec):
    """Normalize a vector. Pure math, no coordinate system logic."""
    length = math.sqrt(vec[0]**2 + vec[1]**2 + vec[2]**2)
    if length > 0:
        return [vec[0]/length, vec[1]/length, vec[2]/length]
    return vec


def _apply_quat_swizzle(quat, pos_cfg):
    """
    Apply coordinate swizzle to quaternion XYZ components.
    Quaternion is [x, y, z, w] - only xyz need swizzling, w stays the same.
    Uses position swizzle rules since quaternion imaginary parts follow position axes.
    """
    x, y, z, w = quat[0], quat[1], quat[2], quat[3]
    mapping = {'x': x, 'y': y, 'z': z, '-x': -x, '-y': -y, '-z': -z}
    return [
        mapping[pos_cfg['out_x']],
        mapping[pos_cfg['out_y']],
        mapping[pos_cfg['out_z']],
        w  # W component unchanged
    ]


def convert_scene_data(scene_data: dict) -> dict:
    """
    Apply coordinate conversion to all scene data.

    Input: scene_data with raw Blender coordinates
    Output: scene_data with N64 coordinates (modified in place)
    """
    config = _load_coord_config()
    pos_cfg = config['position']
    scale_cfg = config['scale']
    dir_cfg = config['direction']
    scale_factor = scale_cfg.get('factor', 1.0)

    for scene_name, scene in scene_data.items():
        # Convert cameras
        for cam in scene.get('cameras', []):
            cam['pos'] = _apply_swizzle(cam['pos'], pos_cfg)
            cam['target'] = _apply_swizzle(cam['target'], pos_cfg)

        # Convert lights
        for light in scene.get('lights', []):
            light['dir'] = _normalize(_apply_swizzle(light['dir'], dir_cfg))

        # Convert objects
        for obj in scene.get('objects', []):
            obj['pos'] = _apply_swizzle(obj['pos'], pos_cfg)
            # Rotation is quaternion [x, y, z, w] - swizzle xyz components
            obj['rot'] = _apply_quat_swizzle(obj['rot'], pos_cfg)
            # Scale includes factor
            raw_scale = _apply_swizzle(obj['scale'], scale_cfg)
            obj['scale'] = [s * scale_factor for s in raw_scale]
            # Convert bounding sphere center (local space offset)
            if 'bounds_center' in obj:
                obj['bounds_center'] = _apply_swizzle(obj['bounds_center'], pos_cfg)
                # Radius is scalar but needs scale factor applied
                obj['bounds_radius'] = obj['bounds_radius'] * scale_factor

    return scene_data
