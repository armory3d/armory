"""
Trait Code Generator - Generates C code for traits from IR.

This module contains the TraitCodeGenerator class and related functions
for preparing template data for traits.h and traits.c.
"""

import json
import os
from typing import Dict, List

from arm import log
from arm.n64.codegen.trait_emitter import TraitEmitter
from arm.n64.codegen import tween_helper


# =============================================================================
# JSON Loading Utilities
# =============================================================================

def _load_ir_json(filename: str, default_key: str, build_dir: str = None) -> dict:
    """Load an IR JSON file from the build directory.

    Searches multiple possible locations and validates IR version.

    Args:
        filename: Name of JSON file (e.g., "n64_traits.json")
        default_key: Key for empty result (e.g., "traits" or "autoloads")
        build_dir: Build directory path (defaults to arm.utils.build_dir())

    Returns:
        Parsed JSON dict with ir_version and data
    """
    import arm.utils

    if build_dir is None:
        build_dir = arm.utils.build_dir()

    possible_paths = [
        os.path.join(build_dir, filename),
        os.path.join(build_dir, "build", filename),
        os.path.join(build_dir, "debug", filename),
    ]

    for path in possible_paths:
        if os.path.exists(path):
            try:
                with open(path, 'r') as f:
                    data = json.load(f)
                    version = data.get("ir_version", 0)
                    if version != 1:
                        log.warn(f"Expected IR version 1, got {version} in {filename}")
                    return data
            except json.JSONDecodeError as e:
                log.error(f"Invalid JSON in {path}: {e}")
            except IOError as e:
                log.error(f"Error reading {path}: {e}")

    return {"ir_version": 0, default_key: {}}


def load_traits_json(build_dir: str = None) -> dict:
    """Load the n64_traits.json file generated by the macro."""
    return _load_ir_json("n64_traits.json", "traits", build_dir)


def get_trait_info(build_dir: str = None) -> dict:
    """
    Load traits JSON and return in expected format.

    This is the main entry point for other code to get trait info.
    Returns dict with:
        ir_version: Schema version
        traits: {TraitName: {module, c_name, members, events, meta}}
    """
    return load_traits_json(build_dir)


# =============================================================================
# Trait Code Generator
# =============================================================================

class TraitCodeGenerator:
    """Generates C code for a single trait from IR.

    Pure 1:1 emitter - all data comes from macro-generated IR.

    Inheritance Support (Option B - Composition):
    - Child data structs embed parent struct at offset 0
    - Each trait generates standalone C code (no IR merging)
    - Python routes member access through inheritance chain
    - super() calls emit as parent lifecycle function calls

    Method Support (Option A - Callable Functions):
    - All non-lifecycle methods are generated as callable C functions
    - Method calls emit as trait_method_call IR nodes
    - Child can call parent methods via super_call IR nodes
    """

    def __init__(self, name: str, ir: Dict, type_overrides: Dict = None, all_traits: Dict = None):
        self.name = name
        self.c_name = ir.get("c_name", "")  # Must be provided by macro
        self.members = ir.get("members", [])
        self.methods = ir.get("methods", {})  # Callable methods (non-lifecycle)
        self.events = ir.get("events", {})
        self.meta = ir.get("meta", {})
        self.type_overrides = type_overrides or {}

        # Inheritance support
        self.parent_name = ir.get("parent")  # Parent trait name (None if no parent)
        self.all_traits = all_traits or {}   # All traits for looking up parent info

        # Build member names list (this trait's own members only)
        member_names = [m.get("name") for m in self.members]

        # Build complete member map including inherited members for routing
        self.member_map = self._build_member_map()

        # Pre-compute the set of virtual method names for this trait
        # (methods that are overridden by child classes)
        self.virtual_method_names = self._compute_virtual_methods()

        # Create emitter with inheritance info
        self.emitter = TraitEmitter(
            name,
            self.c_name,
            member_names,
            is_trait=True,
            parent_name=self.parent_name,
            all_traits=self.all_traits,
            methods=self.methods,
            virtual_methods=self.virtual_method_names,
            member_map=self.member_map
        )
        self._tween_callbacks = []  # Collected tween callbacks from all events
        self._inherited_callbacks = []  # Collected callback wrappers for inherited method calls
        self._signal_inline_callbacks = []  # Collected inline signal callbacks

    def _compute_virtual_methods(self) -> set:
        """Compute the set of method names that need vtable dispatch.

        A method is virtual if it's overridden by any child class.
        """
        virtual = set()
        for method_name in self.methods.keys():
            if self._is_method_virtual(method_name):
                virtual.add(method_name)
        return virtual

    def _build_member_map(self) -> Dict[str, Dict]:
        """Build a map of all members including inherited ones.

        Returns dict of member_name -> {ctype, owner, depth} where:
        - ctype: C type of the member
        - owner: trait name that owns this member
        - depth: inheritance depth (0 = this class, 1 = parent, 2 = grandparent, etc.)
        """
        member_map = {}

        # Add this trait's own members at depth 0
        for m in self.members:
            mname = m.get("name", "")
            member_map[mname] = {
                "ctype": m.get("ctype", "float"),
                "owner": self.name,
                "depth": 0
            }

        # Walk up inheritance chain
        depth = 1
        current_parent = self.parent_name
        while current_parent and current_parent in self.all_traits:
            parent_ir = self.all_traits[current_parent]
            parent_members = parent_ir.get("members", [])
            for m in parent_members:
                mname = m.get("name", "")
                # Don't override if child has same member (child shadows parent)
                if mname not in member_map:
                    member_map[mname] = {
                        "ctype": m.get("ctype", "float"),
                        "owner": current_parent,
                        "depth": depth
                    }
            # Move up to grandparent
            current_parent = parent_ir.get("parent")
            depth += 1

        return member_map

    def _get_member_ctype(self, member: Dict) -> str:
        """Get the C type for a member, applying overrides if present."""
        name = member.get("name", "unknown")
        ctype = member.get("ctype", "float")
        # Apply type override if present
        if self.name in self.type_overrides:
            if name in self.type_overrides[self.name]:
                ctype = self.type_overrides[self.name][name]
        return ctype

    def _find_vtable_owner(self, method_name: str) -> str:
        """Find the trait that originally declares a virtual method.

        The vtable function pointer is stored in the struct of the trait
        that first declares the method. Child overrides set that same pointer.

        Returns the trait name that owns the vtable pointer for this method.
        """
        # Walk up the inheritance chain to find the topmost definition
        # (the trait that first declares this method)
        owner = self.name
        current_parent = self.parent_name

        while current_parent and current_parent in self.all_traits:
            parent_ir = self.all_traits[current_parent]
            parent_methods = parent_ir.get("methods", {})

            if method_name in parent_methods:
                # Parent has this method - it might be the original definer
                # or also an override. Keep walking up.
                owner = current_parent

            current_parent = parent_ir.get("parent")

        return owner

    def _is_method_virtual(self, method_name: str) -> bool:
        """Check if a method should be treated as virtual (needs vtable dispatch).

        Virtual Method Detection System
        ================================

        A method needs vtable dispatch when it can be overridden by child classes
        AND called polymorphically (e.g., through a parent class reference or callback).

        Detection uses a dual approach:

        1. **Haxe Macro Detection (preferred)**
           The N64TraitMacro.hx sets `isVirtual: true` in the MethodIR for public methods.
           This is the authoritative source when available.

        2. **Python Fallback Detection**
           When `isVirtual` isn't in the IR (older IR or clean rebuild needed), we detect
           virtual methods by scanning the inheritance hierarchy:

           a) **Overrides parent**: If this trait's method has the same name as a parent's
              method, it's an override and needs virtual dispatch.

           b) **Overridden by child**: If any child trait has a method with the same name,
              the parent's method might be called polymorphically and needs vtable.

        Vtable Implementation
        ---------------------
        - Each data struct has `_vfn_<methodname>` function pointers for virtual methods
        - Parent classes set vtable pointers to their own implementations
        - Child classes override these pointers in on_ready (after calling parent's on_ready)
        - Virtual calls: `((DataType*)data)->_vfn_method(obj, data, args...)`
        - Direct calls: `trait_methodname(obj, data, args...)`

        Returns:
            True if the method needs vtable dispatch, False otherwise.
        """
        method_ir = self.methods.get(method_name, {})

        # Check explicit flag first (from Haxe macro)
        if method_ir.get("isVirtual", False):
            return True

        # Check if this method overrides a parent's method
        # Walk up the inheritance chain to see if any ancestor has this method
        current_parent = self.parent_name
        while current_parent and current_parent in self.all_traits:
            parent_ir = self.all_traits[current_parent]
            parent_methods = parent_ir.get("methods", {})
            if method_name in parent_methods:
                # This method overrides a parent's method - it's virtual
                return True
            current_parent = parent_ir.get("parent")

        # Fallback: check if any child class overrides this method
        # A method is virtual if it can be overridden
        for trait_name, trait_ir in self.all_traits.items():
            # Check if this trait is a child of the current trait (directly or indirectly)
            if self._is_descendant_of(trait_name, self.name):
                # Check if child has a method with the same name (override)
                child_methods = trait_ir.get("methods", {})
                if method_name in child_methods:
                    return True

        return False

    def _is_descendant_of(self, trait_name: str, ancestor_name: str) -> bool:
        """Check if trait_name is a descendant of ancestor_name."""
        if trait_name == ancestor_name:
            return False

        current = trait_name
        while current and current in self.all_traits:
            current_ir = self.all_traits[current]
            parent = current_ir.get("parent")
            if parent == ancestor_name:
                return True
            current = parent

        return False

    def _get_object_access_path(self) -> str:
        """Get the path to access 'object' member from trait data struct.

        For traits with inheritance, 'object' is in the base struct, so we need
        to traverse the _parent chain. _parent is embedded by value, not pointer.
        For example:
        - No parent: data->object
        - One parent: data->_parent.object
        - Two parents: data->_parent._parent.object
        """
        path = "data->"
        current = self.name
        while current and current in self.all_traits:
            current_ir = self.all_traits[current]
            parent = current_ir.get("parent")
            if parent:
                path += "_parent."
                current = parent
            else:
                break
        return f"{path}object"

    def generate_data_struct(self) -> str:
        """Generate the data struct for trait members and signals.

        For inheritance (Option B - Composition):
        - If trait has a parent, embed parent struct at offset 0
        - This allows safe casting and proper memory layout

        Example:
            typedef struct {
                GameSceneData _parent;  // Embedded parent (if any)
                int32_t score;          // This trait's members
            } LevelData;
        """
        signals = self.meta.get("signals", [])
        signal_handlers = self.meta.get("signal_handlers", [])

        # Find virtual methods that are FIRST DECLARED in this trait (not overrides)
        # Overrides use the parent's vtable pointer, so don't add duplicates
        virtual_methods = []
        for method_name, method_ir in self.methods.items():
            if self._is_method_virtual(method_name):
                # Check if this is the original declaration (not inherited from parent)
                if self._find_vtable_owner(method_name) == self.name:
                    virtual_methods.append(method_ir)

        # Check if we need a struct at all
        # Need struct if: has members, has signals, has signal_handlers, has parent, or has virtual methods
        # Signal handlers need access to 'object' via data->object
        if not self.members and not signals and not signal_handlers and not self.parent_name and not virtual_methods:
            return ""

        lines = [f"typedef struct {{"]

        # Embed parent struct at offset 0 (if any)
        if self.parent_name:
            # Get parent's c_name for proper C identifier
            parent_c_name = self.all_traits.get(self.parent_name, {}).get("c_name", self.parent_name.replace(".", "_"))
            lines.append(f"    {parent_c_name}Data _parent;")
        else:
            # Base trait - add object pointer (like iron.Trait.object)
            lines.append(f"    void* object;")

        # Virtual method function pointers (for polymorphism)
        for vm in virtual_methods:
            vm_name = vm.get("name", "")
            vm_params = vm.get("params", [])
            vm_ret = vm.get("returnType", "void")
            # Build function pointer signature: returnType (*_vfn_methodname)(void* obj, void* data, params...)
            param_types = ["void*", "void*"]  # obj and data
            for p in vm_params:
                param_types.append(p.get("ctype", "void*"))
            params_str = ", ".join(param_types)
            lines.append(f"    {vm_ret} (*_vfn_{vm_name})({params_str});")

        # This trait's own members
        for m in self.members:
            ctype = self._get_member_ctype(m)
            name = m.get("name", "unknown")
            lines.append(f"    {ctype} {name};")

        # Signal members - each signal is an ArmSignal struct
        for sig in signals:
            sig_name = sig.get("name", "")
            if sig_name:
                lines.append(f"    ArmSignal {sig_name};")

        lines.append(f"}} {self.c_name}Data;")

        return "\n".join(lines)

    def _find_tween_callbacks(self, nodes: list) -> list:
        """Recursively find all tween callbacks in IR nodes."""
        # Delegate to shared helper
        return tween_helper.find_tween_callbacks(nodes)

    def _find_nodes_by_type(self, nodes: list, target_type: str) -> list:
        """Recursively find all nodes of a specific type in IR tree.

        Generic helper for finding callback wrappers, tween nodes, etc.
        """
        found = []
        for node in nodes:
            if node is None:
                continue
            node_type = node.get("type", "")
            if node_type == target_type:
                found.append(node)
            # Recurse into children
            if "children" in node and node["children"]:
                found.extend(self._find_nodes_by_type(node["children"], target_type))
            if "args" in node and node["args"]:
                found.extend(self._find_nodes_by_type(node["args"], target_type))
            if "body" in node and isinstance(node.get("body"), list):
                found.extend(self._find_nodes_by_type(node["body"], target_type))
            # Also search inside props (contains then/else_ branches, on_done callbacks, etc.)
            if "props" in node and node["props"]:
                props = node["props"]
                for key, val in props.items():
                    if isinstance(val, list):
                        found.extend(self._find_nodes_by_type(val, target_type))
                    elif isinstance(val, dict):
                        found.extend(self._find_nodes_by_type([val], target_type))
        return found

    def _collect_callbacks_from_all_bodies(self, cache_list: list, finder_fn) -> None:
        """Scan all events AND methods for callbacks using the given finder function.

        Args:
            cache_list: List to store found callbacks (modified in place)
            finder_fn: Function(nodes) -> list of callbacks
        """
        if cache_list:
            return  # Already collected

        # Scan event bodies
        for event_nodes in self.events.values():
            cache_list.extend(finder_fn(event_nodes))

        # Scan method bodies too
        for method_ir in self.methods.values():
            method_body = method_ir.get("body", [])
            cache_list.extend(finder_fn(method_body))

    def _generate_tween_callback(self, callback_info: dict) -> str:
        """Generate a static C callback function for a tween.

        For traits, callbacks can access the trait data via the 'data' pointer
        which is passed through the tween's obj/data parameters.
        """
        # Delegate to shared helper with is_trait=True, pass c_name for captures
        return tween_helper.generate_tween_callback(
            callback_info,
            self.emitter,
            c_name=self.c_name,
            is_trait=True
        )

    def _collect_tween_callbacks(self):
        """Scan all events AND methods for tween callbacks and store them."""
        self._collect_callbacks_from_all_bodies(
            self._tween_callbacks,
            self._find_tween_callbacks
        )

    def generate_tween_callbacks(self) -> str:
        """Generate all tween callback functions for this trait.

        Includes capture globals for any captured function parameters.
        """
        self._collect_tween_callbacks()

        if not self._tween_callbacks:
            return ""

        lines = []

        # First, generate capture globals for any captured params
        callback_param_captures = {}
        for cb in self._tween_callbacks:
            cb_name = cb.get("callback_name", "")
            captures = cb.get("captures", [])
            param_caps = [(c["name"], c.get("ctype", c.get("type", "void*")))
                          for c in captures if c.get("is_param", False)]
            if param_caps:
                callback_param_captures[cb_name] = param_caps

        if callback_param_captures:
            capture_globals = tween_helper.generate_capture_globals(
                callback_param_captures, self.c_name
            )
            lines.extend(capture_globals)
            lines.append("")

        # Then generate callback functions
        seen_callbacks = set()

        for cb in self._tween_callbacks:
            cb_name = cb.get("callback_name", "")
            if cb_name and cb_name not in seen_callbacks:
                seen_callbacks.add(cb_name)
                cb_code = self._generate_tween_callback(cb)
                if cb_code:
                    lines.append(cb_code)
                    lines.append("")

        return "\n".join(lines)

    def _find_inherited_callbacks(self, nodes: list) -> list:
        """Recursively find all callback_wrapper nodes in IR nodes."""
        return self._find_nodes_by_type(nodes, "callback_wrapper")

    def _collect_inherited_callbacks(self):
        """Scan all events AND methods for inherited method callback wrappers."""
        self._collect_callbacks_from_all_bodies(
            self._inherited_callbacks,
            self._find_inherited_callbacks
        )

    def _generate_inherited_callback(self, callback_info: dict) -> str:
        """Generate a C callback function for an inherited method call.

        These callbacks are passed to parent methods which typically pass them
        to tweens. They need obj/data parameters to access trait members.
        The signature matches tween done callbacks: void cb(void* obj, void* data)
        """
        cb_name = callback_info.get("callback_name", "")
        param_name = callback_info.get("param_name")
        param_ctype = callback_info.get("param_ctype", "void")
        body_nodes = callback_info.get("body", [])
        captures = callback_info.get("captures", [])

        if not cb_name:
            return ""

        lines = []

        # All inherited method callbacks need obj/data for member access
        # If the callback also has a value parameter (like Float->Void), include it
        if param_name and param_ctype != "void":
            lines.append(f"static void {cb_name}({param_ctype} {param_name}, void* obj, void* data) {{")
        else:
            lines.append(f"static void {cb_name}(void* obj, void* data) {{")

        # Build param captures map for substitution
        param_captures = {}
        for cap in captures:
            if cap.get("is_param", False):
                cap_name = cap.get("name", "")
                if cap_name:
                    param_captures[cap_name] = f"{self.c_name}_capture_{cap_name}"

        # Use capture-aware emitter if we have param captures
        emitter = self.emitter
        if param_captures:
            emitter = tween_helper._CaptureEmitter(self.emitter, param_captures)

        # Track if obj is used - if body has no ident("object") references, silence warning
        body_code_lines = []
        for node in body_nodes:
            code = emitter.emit(node)
            if code:
                # Handle multi-line statements
                for line in code.split('\n'):
                    if line.strip():
                        if not line.rstrip().endswith((';', '{', '}')):
                            body_code_lines.append(f"    {line};")
                        else:
                            body_code_lines.append(f"    {line}")

        # Check if obj is used in the body
        body_str = "\n".join(body_code_lines)
        obj_used = "obj" in body_str and "ArmObject*)obj" in body_str

        if not obj_used:
            lines.append("    (void)obj;  // Suppress unused parameter warning")

        lines.extend(body_code_lines)
        lines.append("}")
        return "\n".join(lines)

    def generate_inherited_callbacks(self) -> str:
        """Generate all inherited method callback functions for this trait.

        Generates forward declarations first to handle mutual references between
        callbacks (e.g., fadeIn_cb calls fadeOut which uses fadeOut_cb).
        Also generates capture globals for any captured parameters.
        """
        self._collect_inherited_callbacks()

        if not self._inherited_callbacks:
            return ""

        lines = []
        seen_callbacks = set()

        # First, generate capture globals for any captured params
        callback_param_captures = {}
        for cb in self._inherited_callbacks:
            cb_name = cb.get("callback_name", "")
            captures = cb.get("captures", [])
            param_caps = [(c["name"], c.get("ctype", c.get("type", "void*")))
                          for c in captures if c.get("is_param", False)]
            if param_caps:
                callback_param_captures[cb_name] = param_caps

        if callback_param_captures:
            capture_globals = tween_helper.generate_capture_globals(
                callback_param_captures, self.c_name
            )
            lines.extend(capture_globals)
            lines.append("")

        # Second pass: collect unique callbacks with their signatures for forward declarations
        unique_callbacks = []
        for cb in self._inherited_callbacks:
            cb_name = cb.get("callback_name", "")
            if cb_name and cb_name not in seen_callbacks:
                seen_callbacks.add(cb_name)
                unique_callbacks.append(cb)

        # Generate forward declarations with matching signatures
        if len(unique_callbacks) > 1:
            lines.append("// Forward declarations for inherited callbacks")
            for cb in unique_callbacks:
                cb_name = cb.get("callback_name", "")
                param_name = cb.get("param_name")
                param_ctype = cb.get("param_ctype", "void")
                if param_name and param_ctype != "void":
                    lines.append(f"static void {cb_name}({param_ctype} {param_name}, void* obj, void* data);")
                else:
                    lines.append(f"static void {cb_name}(void* obj, void* data);")
            lines.append("")

        # Reset seen for third pass
        seen_callbacks = set()

        # Third pass: generate full definitions
        for cb in self._inherited_callbacks:
            cb_name = cb.get("callback_name", "")
            if cb_name and cb_name not in seen_callbacks:
                seen_callbacks.add(cb_name)
                cb_code = self._generate_inherited_callback(cb)
                if cb_code:
                    lines.append(cb_code)
                    lines.append("")

        return "\n".join(lines)

    def generate_signal_payload_structs(self) -> str:
        """Generate payload struct types for signals with 2+ args.

        Uses struct_def from macro-generated metadata.
        """
        signals = self.meta.get("signals", [])
        lines = []

        for sig in signals:
            struct_def = sig.get("struct_def")
            if struct_def:
                lines.append(struct_def)
                lines.append("")

        return "\n".join(lines)

    def _find_signal_inline_callbacks(self, nodes: list) -> list:
        """Recursively find all inline signal callbacks in IR nodes.

        Searches for signal_call and global_signal_call nodes that have
        props.inline_callback defined (anonymous functions).
        """
        callbacks = []
        for node in nodes:
            if node is None:
                continue
            node_type = node.get("type", "")

            # Check for signal connect nodes with inline callbacks
            if node_type in ("signal_call", "global_signal_call"):
                props = node.get("props", {})
                inline_cb = props.get("inline_callback")
                if inline_cb and isinstance(inline_cb, dict) and inline_cb.get("callback_name"):
                    callbacks.append(inline_cb)

            # Recurse into children
            if "children" in node and node["children"]:
                callbacks.extend(self._find_signal_inline_callbacks(node["children"]))
            if "args" in node and node["args"]:
                callbacks.extend(self._find_signal_inline_callbacks(node["args"]))
            if "body" in node and isinstance(node.get("body"), list):
                callbacks.extend(self._find_signal_inline_callbacks(node["body"]))
            # Recurse into props values
            if "props" in node and node["props"]:
                for val in node["props"].values():
                    if isinstance(val, list):
                        callbacks.extend(self._find_signal_inline_callbacks(val))
                    elif isinstance(val, dict) and "type" in val:
                        callbacks.extend(self._find_signal_inline_callbacks([val]))
        return callbacks

    def _collect_signal_inline_callbacks(self):
        """Scan all events AND methods for inline signal callbacks."""
        self._collect_callbacks_from_all_bodies(
            self._signal_inline_callbacks,
            self._find_signal_inline_callbacks
        )

    def _generate_signal_inline_callback(self, callback_info: dict) -> str:
        """Generate a static C callback for an inline signal callback.

        The callback has ArmSignalHandler signature: void (*)(void *ctx, void *payload)
        For traits, data can be cast to the trait data struct.
        """
        cb_name = callback_info.get("callback_name", "")
        body_nodes = callback_info.get("body", [])
        params = callback_info.get("params", [])

        if not cb_name or not body_nodes:
            return ""

        lines = []
        lines.append(f"static void {self.c_name}_{cb_name}(void* ctx, void* payload) {{")
        lines.append("    (void)ctx;")

        # Generate parameter declarations from payload
        if not params:
            lines.append("    (void)payload;")
        elif len(params) == 1:
            # Single parameter - cast payload directly
            p = params[0]
            pname = p.get("name", "arg")
            ctype = p.get("ctype", "void*")
            if ctype == "const char*":
                lines.append(f"    const char* {pname} = payload ? (const char*)payload : \"\";")
            elif ctype in ("int32_t", "int"):
                lines.append(f"    int32_t {pname} = (int32_t)(intptr_t)payload;")
            elif ctype == "float":
                lines.append(f"    float {pname} = payload ? *(float*)payload : 0.0f;")
            elif ctype == "bool":
                lines.append(f"    bool {pname} = (bool)(intptr_t)payload;")
            else:
                lines.append(f"    {ctype} {pname} = ({ctype})payload;")
        else:
            # Multiple parameters - assume payload is a struct pointer
            lines.append("    // TODO: unpack struct from payload")
            lines.append("    (void)payload;")

        # Emit body
        for node in body_nodes:
            code = self.emitter.emit(node)
            if code:
                for line in code.split('\n'):
                    if line.strip():
                        if not line.rstrip().endswith((';', '{', '}')):
                            lines.append(f"    {line};")
                        else:
                            lines.append(f"    {line}")

        lines.append("}")
        return "\n".join(lines)

    def generate_signal_inline_callbacks(self) -> str:
        """Generate all inline signal callback functions for this trait."""
        self._collect_signal_inline_callbacks()

        if not self._signal_inline_callbacks:
            return ""

        lines = []
        seen_callbacks = set()

        for cb in self._signal_inline_callbacks:
            cb_name = cb.get("callback_name", "")
            if cb_name and cb_name not in seen_callbacks:
                seen_callbacks.add(cb_name)
                cb_code = self._generate_signal_inline_callback(cb)
                if cb_code:
                    lines.append(cb_code)
                    lines.append("")

        return "\n".join(lines)

    def generate_lifecycle_declarations(self) -> List[str]:
        """Generate declarations for lifecycle event handlers."""
        decls = []
        # Match the typedefs in types.h:
        # ArmTraitAddFn: (void *entity, void *data) - no dt, called when trait is added
        # ArmTraitReadyFn: (void *entity, void *data) - no dt
        # ArmTraitFixedUpdateFn: (void *entity, float dt, void *data)
        # ArmTraitUpdateFn: (void *entity, float dt, void *data)
        # ArmTraitLateUpdateFn: (void *entity, float dt, void *data)
        # ArmTraitRemoveFn: (void *entity, void *data) - no dt
        # ArmTraitRender2DFn: (void *entity, void *data) - no dt, for 2D overlay rendering
        decls.append(f"void {self.c_name}_on_add(void* obj, void* data);")
        decls.append(f"void {self.c_name}_on_ready(void* obj, void* data);")
        decls.append(f"void {self.c_name}_on_fixed_update(void* obj, float dt, void* data);")

        # Add declarations for individual fixed update functions if trait has multiple dynamic fixed updates
        dynamic_fixed_updates = self.meta.get("dynamic_fixed_updates", [])
        for callback_name in dynamic_fixed_updates:
            func_name = f"on_fixed_update_{callback_name}"
            decls.append(f"void {self.c_name}_{func_name}(void* obj, float dt, void* data);")

        decls.append(f"void {self.c_name}_on_update(void* obj, float dt, void* data);")

        # Add declarations for individual update functions if trait has multiple dynamic updates
        dynamic_updates = self.meta.get("dynamic_updates", [])
        for callback_name in dynamic_updates:
            func_name = f"on_update_{callback_name}"
            decls.append(f"void {self.c_name}_{func_name}(void* obj, float dt, void* data);")

        decls.append(f"void {self.c_name}_on_late_update(void* obj, float dt, void* data);")
        decls.append(f"void {self.c_name}_on_remove(void* obj, void* data);")
        decls.append(f"void {self.c_name}_on_render2d(void* obj, void* data);")
        return decls

    def generate_button_event_declarations(self) -> List[str]:
        """Generate declarations for button event handlers."""
        decls = []
        for event_name in self.events.keys():
            if event_name.startswith("btn_"):
                # Button events use TraitEventHandler signature: (obj, data, dt)
                decls.append(f"void {self.c_name}_{event_name}(void* obj, void* data, float dt);")
        return decls

    def generate_contact_event_declarations(self) -> List[str]:
        """Generate declarations for contact event handlers."""
        decls = []
        for event_name in self.events.keys():
            if event_name.startswith("contact_"):
                # Contact events use PhysicsContactHandler signature: (obj, data, other)
                decls.append(f"void {self.c_name}_{event_name}(void* obj, void* data, ArmObject* other);")
        return decls

    def generate_signal_handler_declarations(self) -> List[str]:
        """Generate declarations for signal handler callbacks - reads from events."""
        decls = []
        for event_name in self.events.keys():
            if event_name.startswith("signal_"):
                handler_name = event_name[7:]  # Strip "signal_" prefix
                # ArmSignalHandler signature: void (*)(void* ctx, void* payload)
                decls.append(f"void {self.c_name}_{handler_name}(void* ctx, void* payload);")
        return decls

    def generate_method_declarations(self) -> List[str]:
        """Generate declarations for all callable methods (non-lifecycle).

        Methods are generated as C functions with signature:
        return_type cName(void* obj, void* data[, params...]);
        """
        decls = []
        for method_name, method_ir in self.methods.items():
            c_name = method_ir.get("cName", f"{self.c_name}_{method_name.lower()}")
            return_type = method_ir.get("returnType", "void")
            params = method_ir.get("params", [])

            # Build parameter string
            param_strs = ["void* obj", "void* data"]
            for p in params:
                pname = p.get("name", "")
                ctype = p.get("ctype", "int32_t")
                param_strs.append(f"{ctype} {pname}")

            decls.append(f"{return_type} {c_name}({', '.join(param_strs)});")

        return decls

    def generate_method_implementations(self) -> str:
        """Generate C implementations for all callable methods (non-lifecycle).

        Methods are standalone C functions that can be called from any event handler.
        """
        if not self.methods:
            return ""

        impl_lines = []

        for method_name, method_ir in self.methods.items():
            c_name = method_ir.get("cName", f"{self.c_name}_{method_name.lower()}")
            return_type = method_ir.get("returnType", "void")
            params = method_ir.get("params", [])
            body = method_ir.get("body", [])

            # Build parameter string
            param_strs = ["void* obj", "void* data"]
            for p in params:
                pname = p.get("name", "")
                ctype = p.get("ctype", "int32_t")
                param_strs.append(f"{ctype} {pname}")

            impl_lines.append(f"{return_type} {c_name}({', '.join(param_strs)}) {{")

            # Check if method uses render2D features (needs _g2_color local var)
            uses_render2d = self._method_uses_render2d(body)
            if uses_render2d:
                impl_lines.append("    color_t _g2_color = RGBA32(255, 255, 255, 255);")

            # Emit body statements
            if body:
                body_code = self.emitter.emit_statements(body, "    ")
                impl_lines.append(body_code)
            else:
                impl_lines.append("    // Empty method")

            impl_lines.append("}")
            impl_lines.append("")

        return "\n".join(impl_lines)

    def _method_uses_render2d(self, nodes: list) -> bool:
        """Check if method body uses render2D features (graphics2d calls, set_color, etc.)."""
        def scan(node):
            if not node or not isinstance(node, dict):
                return False
            node_type = node.get("type", "")
            # Check for graphics2d-related node types
            if node_type in ("graphics2d_call", "set_color", "g2_set_color",
                             "render2d_set_color", "render2d_fill_rect"):
                return True
            # Recursively scan children and args
            for child in node.get("children", []):
                if scan(child):
                    return True
            for arg in node.get("args", []):
                if scan(arg):
                    return True
            if node.get("object") and scan(node["object"]):
                return True
            return False

        if isinstance(nodes, list):
            for n in nodes:
                if scan(n):
                    return True
        elif isinstance(nodes, dict):
            return scan(nodes)
        return False

    def generate_all_event_implementations(self) -> str:
        """Generate C implementations for all event handlers."""
        impl_lines = [f"// ========== {self.name} =========="]

        # on_add - called when trait is added, BEFORE on_ready
        # Used for setting up autoload references like MainInstances.player = this
        event_nodes = self.events.get("on_add", [])
        impl_lines.append(f"void {self.c_name}_on_add(void* obj, void* data) {{")
        if self.parent_name and self.parent_name in self.all_traits:
            parent_ir = self.all_traits[self.parent_name]
            parent_c_name = parent_ir.get("c_name", self.parent_name.lower())
            impl_lines.append(f"    {parent_c_name}_on_add(obj, data);")
        else:
            # Base trait - initialize object pointer in data struct
            # This must happen for all traits that have a data struct (check same conditions as generate_data_struct)
            signal_handlers = self.meta.get("signal_handlers", [])
            signals = self.meta.get("signals", [])
            has_virtual = any(self._is_method_virtual(m) and self._find_vtable_owner(m) == self.name for m in self.methods)
            if self.members or signals or signal_handlers or has_virtual:
                impl_lines.append(f"    (({self.c_name}Data*)data)->object = obj;")
        body = self.emitter.emit_statements(event_nodes, "    ") if event_nodes else "    // Empty"
        impl_lines.append(body)
        impl_lines.append("}")

        # on_ready - no dt parameter
        event_nodes = self.events.get("on_ready", [])
        impl_lines.append(f"void {self.c_name}_on_ready(void* obj, void* data) {{")

        # Call parent's on_ready FIRST (if we have a parent)
        # Pass full data pointer (not &_parent) so virtual method calls work correctly
        # Since _parent is at offset 0, casting to parent type works
        if self.parent_name and self.parent_name in self.all_traits:
            parent_ir = self.all_traits[self.parent_name]
            parent_c_name = parent_ir.get("c_name", self.parent_name.lower())
            impl_lines.append(f"    {parent_c_name}_on_ready(obj, data);")

        # Initialize virtual function pointers for this trait's virtual methods
        # This happens AFTER parent's on_ready so child overrides replace parent's pointers
        for method_name, method_ir in self.methods.items():
            if self._is_method_virtual(method_name):
                method_c_name = method_ir.get("cName", f"{self.c_name}_{method_name}")
                # Find which ancestor defines this method (has the vtable pointer)
                # If this trait defines it, use this trait's Data type
                # If it's an override, find the ancestor that originally defines it
                vtable_owner = self._find_vtable_owner(method_name)
                vtable_owner_c_name = self.all_traits.get(vtable_owner, {}).get("c_name", vtable_owner.replace(".", "_"))
                impl_lines.append(f"    (({vtable_owner_c_name}Data*)data)->_vfn_{method_name} = {method_c_name};")

        # Allocate tweens at the start of on_ready (before user code)
        tween_alloc_lines = []
        for member in self.members:
            mtype = member.get("ctype", "")
            mname = member.get("name", "")
            if mtype == "ArmTween*":
                tween_alloc_lines.append(f"    (({self.c_name}Data*)data)->{mname} = tween_alloc();")

        if tween_alloc_lines:
            impl_lines.extend(tween_alloc_lines)

        body = self.emitter.emit_statements(event_nodes, "    ") if event_nodes else "    // Empty"
        impl_lines.append(body)
        impl_lines.append("}")
        impl_lines.append("")

        # on_fixed_update - dt before data (ArmTraitFixedUpdateFn)
        # Check if we have multiple dynamic fixed update functions
        dynamic_fixed_updates = self.meta.get("dynamic_fixed_updates", [])

        if dynamic_fixed_updates and len(dynamic_fixed_updates) > 0:
            # Multiple fixed update functions - generate dispatcher that calls each enabled sub-update
            impl_lines.append(f"void {self.c_name}_on_fixed_update(void* obj, float dt, void* data) {{")
            impl_lines.append(f"    {self.c_name}Data* d = ({self.c_name}Data*)data;")
            for callback_name in dynamic_fixed_updates:
                flag_name = f"_fixed_update_{callback_name}_enabled"
                func_name = f"on_fixed_update_{callback_name}"
                impl_lines.append(f"    if (d->{flag_name}) {self.c_name}_{func_name}(obj, dt, data);")
            impl_lines.append("}")
            impl_lines.append("")

            # Generate each individual fixed update function
            for callback_name in dynamic_fixed_updates:
                func_name = f"on_fixed_update_{callback_name}"
                event_nodes = self.events.get(func_name, [])
                body = self.emitter.emit_statements(event_nodes, "    ") if event_nodes else "    // Empty"
                impl_lines.append(f"void {self.c_name}_{func_name}(void* obj, float dt, void* data) {{")
                impl_lines.append(body)
                impl_lines.append("}")
                impl_lines.append("")
        else:
            # Single/no fixed update - original behavior
            event_nodes = self.events.get("on_fixed_update", [])
            body = self.emitter.emit_statements(event_nodes, "    ") if event_nodes else "    // Empty"
            impl_lines.append(f"void {self.c_name}_on_fixed_update(void* obj, float dt, void* data) {{")
            # Add early return guard if trait uses removeFixedUpdate()
            if self.meta.get("has_remove_fixed_update", False):
                impl_lines.append(f"    if (!(({self.c_name}Data*)data)->_fixed_update_enabled) return;")
            impl_lines.append(body)
            impl_lines.append("}")
            impl_lines.append("")

        # on_update - dt before data (ArmTraitUpdateFn)
        # Check if we have multiple dynamic update functions
        dynamic_updates = self.meta.get("dynamic_updates", [])

        if dynamic_updates and len(dynamic_updates) > 0:
            # Multiple update functions - generate dispatcher that calls each enabled sub-update
            impl_lines.append(f"void {self.c_name}_on_update(void* obj, float dt, void* data) {{")
            impl_lines.append(f"    {self.c_name}Data* d = ({self.c_name}Data*)data;")
            for callback_name in dynamic_updates:
                flag_name = f"_update_{callback_name}_enabled"
                func_name = f"on_update_{callback_name}"
                impl_lines.append(f"    if (d->{flag_name}) {self.c_name}_{func_name}(obj, dt, data);")
            impl_lines.append("}")
            impl_lines.append("")

            # Generate each individual update function
            for callback_name in dynamic_updates:
                func_name = f"on_update_{callback_name}"
                event_nodes = self.events.get(func_name, [])
                body = self.emitter.emit_statements(event_nodes, "    ") if event_nodes else "    // Empty"
                impl_lines.append(f"void {self.c_name}_{func_name}(void* obj, float dt, void* data) {{")
                impl_lines.append(body)
                impl_lines.append("}")
                impl_lines.append("")
        else:
            # Single/no update - original behavior
            event_nodes = self.events.get("on_update", [])
            body = self.emitter.emit_statements(event_nodes, "    ") if event_nodes else "    // Empty"
            impl_lines.append(f"void {self.c_name}_on_update(void* obj, float dt, void* data) {{")
            # Add early return guard if trait uses removeUpdate()
            if self.meta.get("has_remove_update", False):
                impl_lines.append(f"    if (!(({self.c_name}Data*)data)->_update_enabled) return;")
            impl_lines.append(body)
            impl_lines.append("}")
            impl_lines.append("")

        # on_late_update - dt before data (ArmTraitLateUpdateFn)
        event_nodes = self.events.get("on_late_update", [])
        body = self.emitter.emit_statements(event_nodes, "    ") if event_nodes else "    // Empty"
        impl_lines.append(f"void {self.c_name}_on_late_update(void* obj, float dt, void* data) {{")
        # Add early return guard if trait uses removeLateUpdate()
        if self.meta.get("has_remove_late_update", False):
            impl_lines.append(f"    if (!(({self.c_name}Data*)data)->_late_update_enabled) return;")
        impl_lines.append(body)
        impl_lines.append("}")
        impl_lines.append("")

        # on_remove - no dt parameter
        event_nodes = self.events.get("on_remove", [])
        body = self.emitter.emit_statements(event_nodes, "    ") if event_nodes else "    // Empty"
        impl_lines.append(f"void {self.c_name}_on_remove(void* obj, void* data) {{")
        impl_lines.append(body)
        # Call parent's on_remove LAST (cleanup in reverse order)
        # Pass full data pointer so virtual method calls work correctly
        if self.parent_name and self.parent_name in self.all_traits:
            parent_ir = self.all_traits[self.parent_name]
            parent_c_name = parent_ir.get("c_name", self.parent_name.lower())
            impl_lines.append(f"    {parent_c_name}_on_remove(obj, data);")
        impl_lines.append("}")
        impl_lines.append("")

        # on_render2d - no dt parameter, for 2D overlay rendering
        event_nodes = self.events.get("on_render2d", [])
        has_render2d_content = event_nodes and len(event_nodes) > 0
        body = self.emitter.emit_statements(event_nodes, "    ") if event_nodes else "    // Empty"
        impl_lines.append(f"void {self.c_name}_on_render2d(void* obj, void* data) {{")
        # Add early return guard if trait uses removeRender2D()
        if self.meta.get("has_remove_render2d", False):
            impl_lines.append(f"    if (!(({self.c_name}Data*)data)->_render2d_enabled) return;")
        # Call parent's on_render2d FIRST (parent renders background)
        # Pass full data pointer so virtual method calls work correctly
        if self.parent_name and self.parent_name in self.all_traits:
            parent_ir = self.all_traits[self.parent_name]
            parent_c_name = parent_ir.get("c_name", self.parent_name.lower())
            impl_lines.append(f"    {parent_c_name}_on_render2d(obj, data);")
        # Only add render2d infrastructure if there's actual content
        if has_render2d_content:
            impl_lines.append("    color_t _g2_color = RGBA32(255, 255, 255, 255);")
            impl_lines.append("    render2d_begin();")
            impl_lines.append(body)
            impl_lines.append("    render2d_end();")
        else:
            impl_lines.append(body)
        impl_lines.append("}")
        impl_lines.append("")

        # Button events - data before dt (TraitEventHandler signature)
        for event_name in self.events.keys():
            if event_name.startswith("btn_"):
                event_nodes = self.events.get(event_name, [])
                body = self.emitter.emit_statements(event_nodes, "    ") if event_nodes else "    // Empty"
                impl_lines.append(f"void {self.c_name}_{event_name}(void* obj, void* data, float dt) {{")
                impl_lines.append(body)
                impl_lines.append("}")
                impl_lines.append("")

        # Contact events - PhysicsContactHandler signature: (obj, data, other)
        for event_name in self.events.keys():
            if event_name.startswith("contact_"):
                event_nodes = self.events.get(event_name, [])
                body = self.emitter.emit_statements(event_nodes, "    ") if event_nodes else "    // Empty"
                impl_lines.append(f"void {self.c_name}_{event_name}(void* obj, void* data, ArmObject* other) {{")
                impl_lines.append(f"    (void)other;  // Available as 'other' in body if needed")
                impl_lines.append(body)
                impl_lines.append("}")
                impl_lines.append("")

        # Signal handler events - use preamble from macro
        signal_handlers = self.meta.get("signal_handlers", [])

        for event_name in self.events.keys():
            if event_name.startswith("signal_"):
                event_nodes = self.events.get(event_name, [])
                body = self.emitter.emit_statements(event_nodes, "    ") if event_nodes else "    // Empty"
                handler_name = event_name[7:]  # Strip "signal_" prefix

                # Find preamble from signal_handlers meta
                # Default includes data cast and obj extraction so handler body can use both.
                # obj is needed for object.remove() and similar calls.
                # Uses _get_object_access_path() to handle inheritance (data->_parent.object etc)
                obj_access = self._get_object_access_path()
                default_preamble = f"{self.c_name}Data* data = ({self.c_name}Data*)ctx; (void)payload; ArmObject* obj = (ArmObject*){obj_access}; (void)obj;"
                preamble = default_preamble
                for sh in signal_handlers:
                    if sh.get("handler_name") == handler_name:
                        preamble = sh.get("preamble", default_preamble)
                        break

                impl_lines.append(f"void {self.c_name}_{handler_name}(void* ctx, void* payload) {{")
                impl_lines.append(f"    {preamble}")
                impl_lines.append(body)
                impl_lines.append("}")
                impl_lines.append("")

        return "\n".join(impl_lines)


# =============================================================================
# Traits File Generation
# =============================================================================

def prepare_traits_template_data(type_overrides: dict = None):
    """Prepare template data for traits.h and traits.c generation.

    Args:
        type_overrides: Optional dict of {trait_name: {member_name: ctype}} overrides

    Returns:
        tuple of (template_data dict, features dict) or (None, None) if no traits
    """
    import arm.utils

    build_dir = arm.utils.build_dir()

    # Load traits from Haxe macro JSON
    data = load_traits_json(build_dir)
    traits = data.get("traits", {})

    if not traits:
        return None, {'has_physics': False, 'has_ui': False}

    # Generate template substitution data and detect features
    return _prepare_traits_template_data(traits, type_overrides)


def _detect_features_in_nodes(nodes) -> dict:
    """Recursively scan IR nodes for feature usage (physics, autoloads, etc.)."""
    features = {'has_physics': False, 'autoloads': set()}

    def scan(node):
        if not node or not isinstance(node, dict):
            return
        node_type = node.get("type", "")
        if node_type == "physics_call":
            features['has_physics'] = True
        elif node_type == "autoload_call":
            # Extract autoload c_name from the call
            props = node.get("props", {})
            c_name = props.get("c_name", "")
            if c_name:
                features['autoloads'].add(c_name)
        elif node_type in ("autoload_field", "autoload_trait_object", "autoload_trait_assign"):
            # Extract autoload c_name from field/trait object access/assignment
            props = node.get("props", {})
            c_name = props.get("autoload", "")
            if c_name:
                features['autoloads'].add(c_name)

        # Recursively scan children and args
        for child in node.get("children", []):
            scan(child)
        for arg in node.get("args", []):
            scan(arg)
        if node.get("object"):
            scan(node["object"])

    if isinstance(nodes, list):
        for n in nodes:
            scan(n)
    elif isinstance(nodes, dict):
        scan(nodes)

    return features


def _validate_ancestor_chain(traits: dict) -> None:
    """Validate that all ancestors in inheritance chains are present in traits.

    Walks up the inheritance chain for each trait and ensures all ancestors
    are included in the traits dict. Raises RuntimeError if any ancestor is
    missing, which would cause C compilation errors.

    Args:
        traits: Dict of trait_name -> trait_ir

    Raises:
        RuntimeError: If an ancestor trait is referenced but not in traits dict
    """
    for trait_name, trait_ir in traits.items():
        # Walk up the entire inheritance chain
        current = trait_ir.get("parent")
        chain = [trait_name]

        while current:
            if current not in traits:
                chain_str = " -> ".join(chain)
                raise RuntimeError(
                    f"N64 Trait Error: '{trait_name}' has ancestor '{current}' that is not "
                    f"included in the N64 build. Inheritance chain: {chain_str} -> {current}. "
                    f"Ensure '{current}' has at least one lifecycle event or member."
                )
            chain.append(current)
            current = traits[current].get("parent")


def _topological_sort_traits(traits: dict) -> List[str]:
    """Sort traits in topological order (parents before children).

    For inheritance to work correctly, parent data structs must be defined
    before child data structs that embed them.

    Args:
        traits: Dict of trait_name -> trait_ir

    Returns:
        List of trait names in topological order
    """
    # Build dependency graph
    # A trait depends on its parent (parent must come first)
    in_degree = {name: 0 for name in traits}
    children = {name: [] for name in traits}

    for name, ir in traits.items():
        parent = ir.get("parent")
        if parent and parent in traits:
            in_degree[name] += 1
            children[parent].append(name)

    # Kahn's algorithm for topological sort
    # Start with traits that have no parents (in_degree = 0)
    queue = [name for name, degree in in_degree.items() if degree == 0]
    result = []

    while queue:
        # Pop from queue (stable sort: use the one added first)
        current = queue.pop(0)
        result.append(current)

        # Reduce in_degree for children
        for child in children[current]:
            in_degree[child] -= 1
            if in_degree[child] == 0:
                queue.append(child)

    # If we didn't process all traits, there's a cycle (shouldn't happen in valid code)
    if len(result) != len(traits):
        log.warn("Circular inheritance detected in traits - this shouldn't happen!")
        # Add remaining traits anyway
        for name in traits:
            if name not in result:
                result.append(name)

    return result


def _prepare_traits_template_data(traits: dict, type_overrides: dict = None) -> tuple:
    """Prepare data for traits.h.j2 and traits.c.j2 templates.

    Uses TraitCodeGenerator for each trait to avoid code duplication.

    Inheritance Processing (Option B - Composition):
    - Traits are sorted in topological order (parents before children)
    - Data structs are emitted with embedded parent structs
    - Emitter routes member access through inheritance chain

    Args:
        traits: Dict of trait_name -> trait_ir from JSON
        type_overrides: Optional dict of {trait_name: {member_name: ctype}} overrides

    Returns:
        tuple of (template_data dict, features dict)
    """
    import arm.utils
    from arm.n64.codegen.autoload_generator import load_autoloads_json

    # Validate all ancestors are present before proceeding
    _validate_ancestor_chain(traits)

    # Sort traits in topological order (parents before children)
    sorted_traits = _topological_sort_traits(traits)

    trait_data_structs = []
    trait_declarations = []
    event_handler_declarations = []
    trait_implementations = []
    tween_callbacks = []  # Tween callback functions (must come before implementations)
    global_signals = set()  # Collect unique global signals

    # Track features across all traits
    all_features = {'has_physics': False, 'has_ui': False, 'has_tween': False}

    # Process traits in topological order (parents first)
    for trait_name in sorted_traits:
        trait_ir = traits[trait_name]
        gen = TraitCodeGenerator(trait_name, trait_ir, type_overrides, all_traits=traits)

        # Header data: signal payload structs + data struct + declarations
        payload_structs = gen.generate_signal_payload_structs()
        if payload_structs:
            trait_data_structs.append(payload_structs)

        struct = gen.generate_data_struct()
        if struct:
            trait_data_structs.append(struct)

        trait_declarations.extend(gen.generate_lifecycle_declarations())
        trait_declarations.extend(gen.generate_method_declarations())  # Callable methods
        event_handler_declarations.extend(gen.generate_button_event_declarations())
        event_handler_declarations.extend(gen.generate_contact_event_declarations())
        event_handler_declarations.extend(gen.generate_signal_handler_declarations())

        # Collect global signals from this trait
        meta = trait_ir.get("meta", {})
        for gs in meta.get("global_signals", []):
            global_signals.add(gs)

        # Check if this trait uses UI
        if meta.get("uses_ui"):
            all_features['has_ui'] = True

        # Check if this trait uses Tween (from meta flag or member type)
        if meta.get("uses_tween"):
            all_features['has_tween'] = True

        # Also check if any member is of type ArmTween*
        for member in trait_ir.get("members", []):
            if member.get("ctype") == "ArmTween*":
                all_features['has_tween'] = True
                break

        # Generate tween callbacks (must come before implementations that reference them)
        tween_cb_code = gen.generate_tween_callbacks()
        if tween_cb_code:
            tween_callbacks.append(f"// Tween callbacks for {trait_name}")
            tween_callbacks.append(tween_cb_code)

        # Generate inherited method callbacks (must come before implementations)
        inherited_cb_code = gen.generate_inherited_callbacks()
        if inherited_cb_code:
            tween_callbacks.append(f"// Inherited method callbacks for {trait_name}")
            tween_callbacks.append(inherited_cb_code)

        # Generate inline signal callbacks (must come before implementations)
        signal_inline_cb_code = gen.generate_signal_inline_callbacks()
        if signal_inline_cb_code:
            tween_callbacks.append(f"// Inline signal callbacks for {trait_name}")
            tween_callbacks.append(signal_inline_cb_code)

        # Implementation data: methods first (they may be called by events), then events
        method_impls = gen.generate_method_implementations()
        if method_impls:
            trait_implementations.append(f"// Methods for {trait_name}")
            trait_implementations.append(method_impls)
        trait_implementations.append(gen.generate_all_event_implementations())

        # Detect features in events
        events = trait_ir.get("events", {})
        for event_name, event_nodes in events.items():
            node_features = _detect_features_in_nodes(event_nodes)
            if node_features['has_physics']:
                all_features['has_physics'] = True
            # Collect autoloads used by this trait
            all_features.setdefault('autoloads', set()).update(node_features.get('autoloads', set()))

    # Also collect global signals from autoloads (they may use signals from other classes)
    build_dir = arm.utils.build_dir()
    autoload_data = load_autoloads_json(build_dir)
    for autoload_name, autoload_ir in autoload_data.get("autoloads", {}).items():
        meta = autoload_ir.get("meta", {})
        for gs in meta.get("global_signals", []):
            global_signals.add(gs)

    # Generate global signal declarations with explicit zero initialization
    global_signal_decls = []
    global_signal_externs = []
    for gs in sorted(global_signals):
        global_signal_decls.append(f"ArmSignal {gs} = {{0}};")
        global_signal_externs.append(f"extern ArmSignal {gs};")

    # Generate autoload include directives
    autoloads_used = all_features.get('autoloads', set())
    autoload_includes = []
    for autoload_cname in sorted(autoloads_used):
        autoload_includes.append(f'#include "../autoloads/{autoload_cname}.h"')

    # Combine tween callbacks with implementations (callbacks must come first)
    all_implementations = []
    if tween_callbacks:
        all_implementations.append("\n".join(tween_callbacks))
    all_implementations.append("\n".join(trait_implementations))

    template_data = {
        "trait_data_structs": "\n\n".join(trait_data_structs),
        "trait_declarations": "\n".join(trait_declarations),
        "event_handler_declarations": "\n".join(event_handler_declarations),
        "trait_implementations": "\n".join(all_implementations),
        "global_signals": "\n".join(global_signal_decls),
        "global_signal_externs": "\n".join(global_signal_externs),
        "autoload_includes": "\n".join(autoload_includes),
        "tween_include": '#include "../system/tween.h"' if all_features['has_tween'] else "",
    }

    return template_data, all_features
