"""
Trait Code Generator - Generates C code for traits from IR.

This module contains the TraitCodeGenerator class and related functions
for preparing template data for traits.h and traits.c.
"""

import json
import os
from typing import Dict, List

from arm import log
from arm.n64.codegen.ir_emitter import IREmitter


# =============================================================================
# JSON Loading Utilities
# =============================================================================

def _load_ir_json(filename: str, default_key: str, build_dir: str = None) -> dict:
    """Load an IR JSON file from the build directory.

    Searches multiple possible locations and validates IR version.

    Args:
        filename: Name of JSON file (e.g., "n64_traits.json")
        default_key: Key for empty result (e.g., "traits" or "autoloads")
        build_dir: Build directory path (defaults to arm.utils.build_dir())

    Returns:
        Parsed JSON dict with ir_version and data
    """
    import arm.utils

    if build_dir is None:
        build_dir = arm.utils.build_dir()

    possible_paths = [
        os.path.join(build_dir, filename),
        os.path.join(build_dir, "build", filename),
        os.path.join(build_dir, "debug", filename),
    ]

    for path in possible_paths:
        if os.path.exists(path):
            try:
                with open(path, 'r') as f:
                    data = json.load(f)
                    version = data.get("ir_version", 0)
                    if version != 1:
                        log.warn(f"Expected IR version 1, got {version} in {filename}")
                    return data
            except json.JSONDecodeError as e:
                log.error(f"Invalid JSON in {path}: {e}")
            except IOError as e:
                log.error(f"Error reading {path}: {e}")

    return {"ir_version": 0, default_key: {}}


def load_traits_json(build_dir: str = None) -> dict:
    """Load the n64_traits.json file generated by the macro."""
    return _load_ir_json("n64_traits.json", "traits", build_dir)


def get_trait_info(build_dir: str = None) -> dict:
    """
    Load traits JSON and return in expected format.

    This is the main entry point for other code to get trait info.
    Returns dict with:
        ir_version: Schema version
        traits: {TraitName: {module, c_name, members, events, meta}}
    """
    return load_traits_json(build_dir)


# =============================================================================
# Trait Code Generator
# =============================================================================

class TraitCodeGenerator:
    """Generates C code for a single trait from IR.

    Pure 1:1 emitter - all data comes from macro-generated IR.
    """

    def __init__(self, name: str, ir: Dict, type_overrides: Dict = None):
        self.name = name
        self.c_name = ir.get("c_name", "")  # Must be provided by macro
        self.members = ir.get("members", [])
        self.events = ir.get("events", {})
        self.meta = ir.get("meta", {})
        self.type_overrides = type_overrides or {}

        member_names = [m.get("name") for m in self.members]
        self.emitter = IREmitter(name, self.c_name, member_names)
        self._tween_callbacks = []  # Collected tween callbacks from all events

    def _get_member_ctype(self, member: Dict) -> str:
        """Get the C type for a member, applying overrides if present."""
        name = member.get("name", "unknown")
        ctype = member.get("ctype", "float")
        # Apply type override if present
        if self.name in self.type_overrides:
            if name in self.type_overrides[self.name]:
                ctype = self.type_overrides[self.name][name]
        return ctype

    def generate_data_struct(self) -> str:
        """Generate the data struct for trait members and signals."""
        signals = self.meta.get("signals", [])

        if not self.members and not signals:
            return ""

        lines = [f"typedef struct {{"]

        # Regular members
        for m in self.members:
            ctype = self._get_member_ctype(m)
            name = m.get("name", "unknown")
            lines.append(f"    {ctype} {name};")

        # Signal members - each signal is an ArmSignal struct
        for sig in signals:
            sig_name = sig.get("name", "")
            if sig_name:
                lines.append(f"    ArmSignal {sig_name};")

        lines.append(f"}} {self.name}Data;")

        return "\n".join(lines)

    def _find_tween_callbacks(self, nodes: list) -> list:
        """Recursively find all tween callbacks in IR nodes."""
        callbacks = []
        for node in nodes:
            if node is None:
                continue
            node_type = node.get("type", "")
            if node_type in ("tween_float", "tween_vec4", "tween_delay"):
                props = node.get("props", {})
                on_update = props.get("on_update")
                on_done = props.get("on_done")
                if on_update:
                    callbacks.append(on_update)
                if on_done:
                    callbacks.append(on_done)
            # Recurse into children, args, body
            for key in ("children", "args", "body"):
                children = node.get(key, [])
                if children:
                    callbacks.extend(self._find_tween_callbacks(children))
            # Also recurse into object (for method_call nodes wrapping tweens like .start())
            obj = node.get("object")
            if obj and isinstance(obj, dict):
                callbacks.extend(self._find_tween_callbacks([obj]))
            # Recurse into then/else_ for if nodes
            props = node.get("props", {})
            then_nodes = props.get("then", [])
            if then_nodes:
                callbacks.extend(self._find_tween_callbacks(then_nodes))
            else_nodes = props.get("else_", [])
            if else_nodes:
                callbacks.extend(self._find_tween_callbacks(else_nodes))
        return callbacks

    def _generate_tween_callback(self, callback_info: dict) -> str:
        """Generate a static C callback function for a tween.

        For traits, callbacks can access the trait data via the 'data' pointer
        which is passed through the tween's obj/data parameters.
        """
        if not callback_info:
            return ""

        cb_name = callback_info.get("callback_name", "")
        cb_type = callback_info.get("callback_type", "")
        body_nodes = callback_info.get("body", [])
        param_name = callback_info.get("param_name") or "v"  # Handle null from JSON

        if not cb_name or not body_nodes:
            return ""

        lines = []

        if cb_type == "float":
            # Float callback: void name_float(float value, void* obj, void* data)
            lines.append(f"static void {cb_name}_float(float {param_name}, void* obj, void* data) {{")
            lines.append("    (void)obj;")
        elif cb_type == "vec4":
            # Vec4 callback: void name_vec4(ArmVec4* value, void* obj, void* data)
            lines.append(f"static void {cb_name}_vec4(ArmVec4* {param_name}, void* obj, void* data) {{")
            lines.append("    (void)obj;")
        elif cb_type == "done":
            # Done callback: void name_done(void* obj, void* data)
            lines.append(f"static void {cb_name}_done(void* obj, void* data) {{")
            lines.append("    (void)obj;")
        else:
            return ""

        # For traits, the emitter already handles member access via data->member
        # Emit body using the trait's emitter
        for node in body_nodes:
            code = self.emitter.emit(node)
            if code and code != "":
                for line in code.split('\n'):
                    if line.strip():
                        if not line.strip().endswith((';', '{', '}')):
                            lines.append(f"    {line};")
                        else:
                            lines.append(f"    {line}")

        lines.append("}")
        return "\n".join(lines)

    def _collect_tween_callbacks(self):
        """Scan all events for tween callbacks and store them."""
        if self._tween_callbacks:
            return  # Already collected

        for event_name, event_nodes in self.events.items():
            found = self._find_tween_callbacks(event_nodes)
            self._tween_callbacks.extend(found)

    def generate_tween_callbacks(self) -> str:
        """Generate all tween callback functions for this trait."""
        self._collect_tween_callbacks()

        if not self._tween_callbacks:
            return ""

        lines = []
        seen_callbacks = set()

        for cb in self._tween_callbacks:
            cb_name = cb.get("callback_name", "")
            if cb_name and cb_name not in seen_callbacks:
                seen_callbacks.add(cb_name)
                cb_code = self._generate_tween_callback(cb)
                if cb_code:
                    lines.append(cb_code)
                    lines.append("")

        return "\n".join(lines)

    def generate_signal_payload_structs(self) -> str:
        """Generate payload struct types for signals with 2+ args.

        Uses struct_def from macro-generated metadata.
        """
        signals = self.meta.get("signals", [])
        lines = []

        for sig in signals:
            struct_def = sig.get("struct_def")
            if struct_def:
                lines.append(struct_def)
                lines.append("")

        return "\n".join(lines)

    def generate_lifecycle_declarations(self) -> List[str]:
        """Generate declarations for lifecycle event handlers."""
        decls = []
        # Match the typedefs in types.h:
        # ArmTraitReadyFn: (void *entity, void *data) - no dt
        # ArmTraitFixedUpdateFn: (void *entity, float dt, void *data)
        # ArmTraitUpdateFn: (void *entity, float dt, void *data)
        # ArmTraitLateUpdateFn: (void *entity, float dt, void *data)
        # ArmTraitRemoveFn: (void *entity, void *data) - no dt
        # ArmTraitRender2DFn: (void *entity, void *data) - no dt, for 2D overlay rendering
        decls.append(f"void {self.c_name}_on_ready(void* obj, void* data);")
        decls.append(f"void {self.c_name}_on_fixed_update(void* obj, float dt, void* data);")
        decls.append(f"void {self.c_name}_on_update(void* obj, float dt, void* data);")
        decls.append(f"void {self.c_name}_on_late_update(void* obj, float dt, void* data);")
        decls.append(f"void {self.c_name}_on_remove(void* obj, void* data);")
        decls.append(f"void {self.c_name}_on_render2d(void* obj, void* data);")
        return decls

    def generate_button_event_declarations(self) -> List[str]:
        """Generate declarations for button event handlers."""
        decls = []
        for event_name in self.events.keys():
            if event_name.startswith("btn_"):
                # Button events use TraitEventHandler signature: (obj, data, dt)
                decls.append(f"void {self.c_name}_{event_name}(void* obj, void* data, float dt);")
        return decls

    def generate_contact_event_declarations(self) -> List[str]:
        """Generate declarations for contact event handlers."""
        decls = []
        for event_name in self.events.keys():
            if event_name.startswith("contact_"):
                # Contact events use PhysicsContactHandler signature: (obj, data, other)
                decls.append(f"void {self.c_name}_{event_name}(void* obj, void* data, ArmObject* other);")
        return decls

    def generate_signal_handler_declarations(self) -> List[str]:
        """Generate declarations for signal handler callbacks - reads from events."""
        decls = []
        for event_name in self.events.keys():
            if event_name.startswith("signal_"):
                handler_name = event_name[7:]  # Strip "signal_" prefix
                # ArmSignalHandler signature: void (*)(void* ctx, void* payload)
                decls.append(f"void {self.c_name}_{handler_name}(void* ctx, void* payload);")
        return decls

    def generate_all_event_implementations(self) -> str:
        """Generate C implementations for all event handlers."""
        impl_lines = [f"// ========== {self.name} =========="]

        # on_ready - no dt parameter
        event_nodes = self.events.get("on_ready", [])
        impl_lines.append(f"void {self.c_name}_on_ready(void* obj, void* data) {{")

        # Allocate tweens at the start of on_ready (before user code)
        tween_alloc_lines = []
        for member in self.members:
            mtype = member.get("ctype", "")
            mname = member.get("name", "")
            if mtype == "ArmTween*":
                tween_alloc_lines.append(f"    (({self.name}Data*)data)->{mname} = tween_alloc();")

        if tween_alloc_lines:
            impl_lines.extend(tween_alloc_lines)

        body = self.emitter.emit_statements(event_nodes, "    ") if event_nodes else "    // Empty"
        impl_lines.append(body)
        impl_lines.append("}")
        impl_lines.append("")

        # on_fixed_update - dt before data (ArmTraitFixedUpdateFn)
        event_nodes = self.events.get("on_fixed_update", [])
        body = self.emitter.emit_statements(event_nodes, "    ") if event_nodes else "    // Empty"
        impl_lines.append(f"void {self.c_name}_on_fixed_update(void* obj, float dt, void* data) {{")
        impl_lines.append(body)
        impl_lines.append("}")
        impl_lines.append("")

        # on_update - dt before data (ArmTraitUpdateFn)
        event_nodes = self.events.get("on_update", [])
        body = self.emitter.emit_statements(event_nodes, "    ") if event_nodes else "    // Empty"
        impl_lines.append(f"void {self.c_name}_on_update(void* obj, float dt, void* data) {{")
        # Add early return guard if trait uses removeUpdate()
        if self.meta.get("has_remove_update", False):
            impl_lines.append(f"    if (!(({self.name}Data*)data)->_update_enabled) return;")
        impl_lines.append(body)
        impl_lines.append("}")
        impl_lines.append("")

        # on_late_update - dt before data (ArmTraitLateUpdateFn)
        event_nodes = self.events.get("on_late_update", [])
        body = self.emitter.emit_statements(event_nodes, "    ") if event_nodes else "    // Empty"
        impl_lines.append(f"void {self.c_name}_on_late_update(void* obj, float dt, void* data) {{")
        # Add early return guard if trait uses removeLateUpdate()
        if self.meta.get("has_remove_late_update", False):
            impl_lines.append(f"    if (!(({self.name}Data*)data)->_late_update_enabled) return;")
        impl_lines.append(body)
        impl_lines.append("}")
        impl_lines.append("")

        # on_remove - no dt parameter
        event_nodes = self.events.get("on_remove", [])
        body = self.emitter.emit_statements(event_nodes, "    ") if event_nodes else "    // Empty"
        impl_lines.append(f"void {self.c_name}_on_remove(void* obj, void* data) {{")
        impl_lines.append(body)
        impl_lines.append("}")
        impl_lines.append("")

        # on_render2d - no dt parameter, for 2D overlay rendering
        event_nodes = self.events.get("on_render2d", [])
        has_render2d_content = event_nodes and len(event_nodes) > 0
        body = self.emitter.emit_statements(event_nodes, "    ") if event_nodes else "    // Empty"
        impl_lines.append(f"void {self.c_name}_on_render2d(void* obj, void* data) {{")
        # Add early return guard if trait uses removeRender2D()
        if self.meta.get("has_remove_render2d", False):
            impl_lines.append(f"    if (!(({self.name}Data*)data)->_render2d_enabled) return;")
        # Only add render2d infrastructure if there's actual content
        if has_render2d_content:
            impl_lines.append("    color_t _g2_color = RGBA32(255, 255, 255, 255);")
            impl_lines.append("    render2d_begin();")
            impl_lines.append(body)
            impl_lines.append("    render2d_end();")
        else:
            impl_lines.append(body)
        impl_lines.append("}")
        impl_lines.append("")

        # Button events - data before dt (TraitEventHandler signature)
        for event_name in self.events.keys():
            if event_name.startswith("btn_"):
                event_nodes = self.events.get(event_name, [])
                body = self.emitter.emit_statements(event_nodes, "    ") if event_nodes else "    // Empty"
                impl_lines.append(f"void {self.c_name}_{event_name}(void* obj, void* data, float dt) {{")
                impl_lines.append(body)
                impl_lines.append("}")
                impl_lines.append("")

        # Contact events - PhysicsContactHandler signature: (obj, data, other)
        for event_name in self.events.keys():
            if event_name.startswith("contact_"):
                event_nodes = self.events.get(event_name, [])
                body = self.emitter.emit_statements(event_nodes, "    ") if event_nodes else "    // Empty"
                impl_lines.append(f"void {self.c_name}_{event_name}(void* obj, void* data, ArmObject* other) {{")
                impl_lines.append(f"    (void)other;  // Available as 'other' in body if needed")
                impl_lines.append(body)
                impl_lines.append("}")
                impl_lines.append("")

        # Signal handler events - use preamble from macro
        signal_handlers = self.meta.get("signal_handlers", [])

        for event_name in self.events.keys():
            if event_name.startswith("signal_"):
                event_nodes = self.events.get(event_name, [])
                body = self.emitter.emit_statements(event_nodes, "    ") if event_nodes else "    // Empty"
                handler_name = event_name[7:]  # Strip "signal_" prefix

                # Find preamble from signal_handlers meta
                # Default includes data cast so handler body can use 'data'
                default_preamble = f"{self.name}Data* data = ({self.name}Data*)ctx; (void)payload;"
                preamble = default_preamble
                for sh in signal_handlers:
                    if sh.get("handler_name") == handler_name:
                        preamble = sh.get("preamble", default_preamble)
                        break

                impl_lines.append(f"void {self.c_name}_{handler_name}(void* ctx, void* payload) {{")
                impl_lines.append(f"    {preamble}")
                impl_lines.append(body)
                impl_lines.append("}")
                impl_lines.append("")

        return "\n".join(impl_lines)


# =============================================================================
# Traits File Generation
# =============================================================================

def prepare_traits_template_data(type_overrides: dict = None):
    """Prepare template data for traits.h and traits.c generation.

    Args:
        type_overrides: Optional dict of {trait_name: {member_name: ctype}} overrides

    Returns:
        tuple of (template_data dict, features dict) or (None, None) if no traits
    """
    import arm.utils

    build_dir = arm.utils.build_dir()

    # Load traits from Haxe macro JSON
    data = load_traits_json(build_dir)
    traits = data.get("traits", {})

    if not traits:
        return None, {'has_physics': False, 'has_ui': False}

    # Generate template substitution data and detect features
    return _prepare_traits_template_data(traits, type_overrides)


def _detect_features_in_nodes(nodes) -> dict:
    """Recursively scan IR nodes for feature usage (physics, autoloads, etc.)."""
    features = {'has_physics': False, 'autoloads': set()}

    def scan(node):
        if not node or not isinstance(node, dict):
            return
        node_type = node.get("type", "")
        if node_type == "physics_call":
            features['has_physics'] = True
        elif node_type == "autoload_call":
            # Extract autoload c_name from the call
            props = node.get("props", {})
            c_name = props.get("c_name", "")
            if c_name:
                features['autoloads'].add(c_name)

        # Recursively scan children and args
        for child in node.get("children", []):
            scan(child)
        for arg in node.get("args", []):
            scan(arg)
        if node.get("object"):
            scan(node["object"])

    if isinstance(nodes, list):
        for n in nodes:
            scan(n)
    elif isinstance(nodes, dict):
        scan(nodes)

    return features


def _prepare_traits_template_data(traits: dict, type_overrides: dict = None) -> tuple:
    """Prepare data for traits.h.j2 and traits.c.j2 templates.

    Uses TraitCodeGenerator for each trait to avoid code duplication.

    Args:
        traits: Dict of trait_name -> trait_ir from JSON
        type_overrides: Optional dict of {trait_name: {member_name: ctype}} overrides

    Returns:
        tuple of (template_data dict, features dict)
    """
    import arm.utils
    from arm.n64.codegen.autoload_generator import load_autoloads_json

    trait_data_structs = []
    trait_declarations = []
    event_handler_declarations = []
    trait_implementations = []
    tween_callbacks = []  # Tween callback functions (must come before implementations)
    global_signals = set()  # Collect unique global signals

    # Track features across all traits
    all_features = {'has_physics': False, 'has_ui': False, 'has_tween': False}

    for trait_name, trait_ir in traits.items():
        gen = TraitCodeGenerator(trait_name, trait_ir, type_overrides)

        # Header data: signal payload structs + data struct + declarations
        payload_structs = gen.generate_signal_payload_structs()
        if payload_structs:
            trait_data_structs.append(payload_structs)

        struct = gen.generate_data_struct()
        if struct:
            trait_data_structs.append(struct)

        trait_declarations.extend(gen.generate_lifecycle_declarations())
        event_handler_declarations.extend(gen.generate_button_event_declarations())
        event_handler_declarations.extend(gen.generate_contact_event_declarations())
        event_handler_declarations.extend(gen.generate_signal_handler_declarations())

        # Collect global signals from this trait
        meta = trait_ir.get("meta", {})
        for gs in meta.get("global_signals", []):
            global_signals.add(gs)

        # Check if this trait uses UI
        if meta.get("uses_ui"):
            all_features['has_ui'] = True

        # Check if this trait uses Tween (from meta flag or member type)
        if meta.get("uses_tween"):
            all_features['has_tween'] = True

        # Also check if any member is of type ArmTween*
        for member in trait_ir.get("members", []):
            if member.get("ctype") == "ArmTween*":
                all_features['has_tween'] = True
                break

        # Generate tween callbacks (must come before implementations that reference them)
        tween_cb_code = gen.generate_tween_callbacks()
        if tween_cb_code:
            tween_callbacks.append(f"// Tween callbacks for {trait_name}")
            tween_callbacks.append(tween_cb_code)

        # Implementation data
        trait_implementations.append(gen.generate_all_event_implementations())

        # Detect features in events
        events = trait_ir.get("events", {})
        for event_name, event_nodes in events.items():
            node_features = _detect_features_in_nodes(event_nodes)
            if node_features['has_physics']:
                all_features['has_physics'] = True
            # Collect autoloads used by this trait
            all_features.setdefault('autoloads', set()).update(node_features.get('autoloads', set()))

    # Also collect global signals from autoloads (they may use signals from other classes)
    build_dir = arm.utils.build_dir()
    autoload_data = load_autoloads_json(build_dir)
    for autoload_name, autoload_ir in autoload_data.get("autoloads", {}).items():
        meta = autoload_ir.get("meta", {})
        for gs in meta.get("global_signals", []):
            global_signals.add(gs)

    # Generate global signal declarations with explicit zero initialization
    global_signal_decls = []
    global_signal_externs = []
    for gs in sorted(global_signals):
        global_signal_decls.append(f"ArmSignal {gs} = {{0}};")
        global_signal_externs.append(f"extern ArmSignal {gs};")

    # Generate autoload include directives
    autoloads_used = all_features.get('autoloads', set())
    autoload_includes = []
    for autoload_cname in sorted(autoloads_used):
        autoload_includes.append(f'#include "../autoloads/{autoload_cname}.h"')

    # Combine tween callbacks with implementations (callbacks must come first)
    all_implementations = []
    if tween_callbacks:
        all_implementations.append("\n".join(tween_callbacks))
    all_implementations.append("\n".join(trait_implementations))

    template_data = {
        "trait_data_structs": "\n\n".join(trait_data_structs),
        "trait_declarations": "\n".join(trait_declarations),
        "event_handler_declarations": "\n".join(event_handler_declarations),
        "trait_implementations": "\n".join(all_implementations),
        "global_signals": "\n".join(global_signal_decls),
        "global_signal_externs": "\n".join(global_signal_externs),
        "autoload_includes": "\n".join(autoload_includes),
        "tween_include": '#include "../system/tween.h"' if all_features['has_tween'] else "",
    }

    return template_data, all_features
