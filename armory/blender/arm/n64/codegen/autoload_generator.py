"""
Autoload Generator - Generates C code for autoload classes from IR.

This module contains functions for loading autoload JSON data and preparing
template data for autoload headers and source files.
"""

import json
import os
from typing import Dict, List

from arm import log
from arm.n64.codegen.autoload_emitter import AutoloadEmitter
from arm.n64.codegen import tween_helper


def load_autoloads_json(build_dir: str = None) -> dict:
    """Load the n64_autoloads.json file generated by the macro."""
    import arm.utils

    if build_dir is None:
        build_dir = arm.utils.build_dir()

    possible_paths = [
        os.path.join(build_dir, "n64_autoloads.json"),
        os.path.join(build_dir, "build", "n64_autoloads.json"),
        os.path.join(build_dir, "debug", "n64_autoloads.json"),
    ]

    for path in possible_paths:
        if os.path.exists(path):
            try:
                with open(path, 'r') as f:
                    data = json.load(f)
                    version = data.get("ir_version", 0)
                    if version != 1:
                        log.warn(f"Expected IR version 1, got {version} in n64_autoloads.json")
                    return data
            except json.JSONDecodeError as e:
                log.error(f"Invalid JSON in {path}: {e}")
            except IOError as e:
                log.error(f"Error reading {path}: {e}")

    return {"ir_version": 0, "autoloads": {}}


def _prepare_autoload_template_data(name: str, autoload_ir: dict) -> dict:
    """Prepare template data for a single autoload.

    Args:
        name: Autoload class name
        autoload_ir: IR dict from macro

    Returns:
        dict with all template placeholders
    """
    c_name = autoload_ir.get("c_name", name.lower())
    order = autoload_ir.get("order", 100)
    members = autoload_ir.get("members", [])
    functions = autoload_ir.get("functions", [])
    meta = autoload_ir.get("meta", {})
    signals = meta.get("signals", [])

    # Create emitter for code generation - use AutoloadIREmitter for proper prefixing
    member_names = [m["name"] for m in members]
    member_types = {m["name"]: m.get("ctype", "int32_t") for m in members}
    function_names = [f["name"] for f in functions]
    emitter = AutoloadEmitter(name, c_name, member_names, function_names, member_types)

    # Helper to emit default value
    def emit_default_value(default: dict, ctype: str) -> str:
        if default is None:
            if ctype == "float":
                return "0.0f"
            elif ctype in ("int32_t", "int", "uint32_t", "uint8_t"):
                return "0"
            elif ctype == "bool":
                return "false"
            elif ctype == "const char*":
                return '""'
            elif ctype == "ArmSoundHandle":
                return "{-1, 0, -1, 1.0f, true}"  # channel=-1, mix_channel=0, sound_slot=-1, volume=1.0, finished=true
            elif ctype == "ArmTween*":
                return "NULL"  # Tweens allocated in init, not at global scope
            else:
                return "0"
        # For tween_alloc nodes, we return NULL here (allocation happens in init)
        if isinstance(default, dict) and default.get("type") == "tween_alloc":
            return "NULL"
        return emitter.emit(default)

    # Helper to generate function declaration
    def generate_function_declaration(func: dict) -> str:
        return_type = func.get("return_type", "void")
        func_c_name = func.get("c_name", f"{c_name}_{func.get('name', '')}")
        params = func.get("params", [])
        if params:
            param_str = ", ".join(f"{p.get('ctype', 'int32_t')} {p.get('name', '')}" for p in params)
        else:
            param_str = "void"
        return f"{return_type} {func_c_name}({param_str})"

    # Helper to generate function implementation
    def generate_function_implementation(func: dict, is_static: bool = False, maybe_unused: bool = False) -> str:
        decl = generate_function_declaration(func)
        prefix = ""
        if is_static:
            prefix = "static "
        if maybe_unused:
            prefix += "__attribute__((unused)) "
        lines = [f"{prefix}{decl} {{"]

        # Populate param_types for this function so emit_binop can detect string parameters
        params = func.get("params", [])
        emitter.param_types = {p.get("name", ""): p.get("ctype", "int32_t") for p in params}

        body = func.get("body", [])
        for node in body:
            code = emitter.emit(node)
            if code and code != "":
                for line in code.split('\n'):
                    if line.strip():
                        if not line.strip().endswith((';', '{', '}')):
                            lines.append(f"    {line};")
                        else:
                            lines.append(f"    {line}")

        # Clear param_types after processing
        emitter.param_types = {}

        lines.append("}")
        return "\n".join(lines)

    # Collect all tween callbacks from all functions using shared helper
    all_tween_callbacks = []
    for func in functions:
        body = func.get("body", [])
        func_params = {p.get("name"): p.get("ctype", "int32_t") for p in func.get("params", [])}
        found = tween_helper.find_tween_callbacks(body)

        # Use shared helper to collect captures
        found, _ = tween_helper.collect_callback_captures(
            found, func_params, member_names, c_name
        )
        all_tween_callbacks.extend(found)

    # Build capture info map
    callback_param_captures = {}
    for cb in all_tween_callbacks:
        cb_name = cb.get("callback_name", "")
        captures = cb.get("captures", [])
        param_caps = [(c["name"], c["ctype"]) for c in captures if c.get("is_param", False)]
        if param_caps:
            callback_param_captures[cb_name] = param_caps

    # Generate capture globals using shared helper
    capture_global_lines = tween_helper.generate_capture_globals(callback_param_captures, c_name)

    # Generate tween callback functions (deduplicated by name)
    tween_callback_lines = []
    seen_callbacks = set()
    for cb in all_tween_callbacks:
        cb_name = cb.get("callback_name", "")
        if cb_name and cb_name not in seen_callbacks:
            seen_callbacks.add(cb_name)
            cb_code = tween_helper.generate_tween_callback(cb, emitter, c_name, is_trait=False)
            if cb_code:
                tween_callback_lines.append(cb_code)

    # Build signal structs
    signal_struct_lines = []
    for sig in signals:
        struct_def = sig.get("struct_def")
        if struct_def:
            signal_struct_lines.append(struct_def)

    # Build forward declarations for non-trait pointer types
    # Trait data types (ending with Data*) are defined in traits.h, so we include that instead
    forward_decl_lines = []
    needs_traits_include = False
    seen_types = set()
    if members:
        for m in members:
            ctype = m.get("ctype", "")
            # Check if it's a trait data pointer type (ends with Data*)
            if ctype.endswith("Data*"):
                # This is a trait type - we need to include traits.h
                needs_traits_include = True
                # Don't forward-declare, traits.h has the full definition

    # Generate traits include if needed
    traits_include = '\n#include "../data/traits.h"' if needs_traits_include else ''

    # Build member externs (for header)
    member_extern_lines = []
    if members:
        member_extern_lines.append(f"// {name} members")
        for m in members:
            ctype = m.get("ctype", "int32_t")
            mname = m.get("name", "")
            member_extern_lines.append(f"extern {ctype} {c_name}_{mname};")

    # Build signal externs (for header)
    signal_extern_lines = []
    if signals:
        signal_extern_lines.append(f"// {name} signals")
        for sig in signals:
            sig_name = sig.get("name", "")
            signal_extern_lines.append(f"extern ArmSignal {c_name}_{sig_name};")

    # Build function declarations (public only, for header)
    func_decl_lines = []
    public_funcs = [f for f in functions if f.get("is_public", False) and f.get("name") != "init"]
    if public_funcs:
        func_decl_lines.append(f"// {name} public functions")
        for func in public_funcs:
            decl = generate_function_declaration(func)
            func_decl_lines.append(f"{decl};")

    # Build member definitions (for source)
    member_def_lines = []
    if members:
        member_def_lines.append(f"// {name} members")
        for m in members:
            ctype = m.get("ctype", "int32_t")
            mname = m.get("name", "")
            default = m.get("default_value")
            init_value = emit_default_value(default, ctype)
            member_def_lines.append(f"{ctype} {c_name}_{mname} = {init_value};")

    # Build signal definitions (for source)
    signal_def_lines = []
    if signals:
        signal_def_lines.append(f"// {name} signals")
        for sig in signals:
            sig_name = sig.get("name", "")
            signal_def_lines.append(f"ArmSignal {c_name}_{sig_name} = {{0}};")

    # Build private function implementations
    private_func_lines = []
    private_funcs = [f for f in functions if not f.get("is_public", False) and f.get("name") != "init"]
    for func in private_funcs:
        # Mark as maybe_unused since setters might not be called externally
        impl = generate_function_implementation(func, is_static=True, maybe_unused=True)
        private_func_lines.append(impl)

    # Build signal handler wrappers
    # When a function is connected to a signal, we need a wrapper with the correct signature
    signal_handlers = meta.get("signal_handlers", [])
    signal_wrapper_lines = []
    for sh in signal_handlers:
        handler_name = sh.get("handler_name", "")
        if handler_name:
            # Find the function to get its parameters
            handler_func = next((f for f in functions if f["name"] == handler_name), None)
            params = handler_func.get("params", []) if handler_func else []

            # Generate wrapper that calls the actual function
            # Wrapper has ArmSignalHandler signature: void (*)(void* ctx, void* payload)
            wrapper_lines = [
                f"static void {c_name}_{handler_name}_wrapper(void* ctx, void* payload) {{",
                f"    (void)ctx;",
            ]

            if not params:
                # No parameters - just suppress payload warning and call
                wrapper_lines.append(f"    (void)payload;")
                wrapper_lines.append(f"    {c_name}_{handler_name}();")
            elif len(params) == 1:
                # Single parameter - check if signal provides this or if it's ignored
                # For signals like sceneLoaded that send const char*, cast payload
                p = params[0]
                ptype = p.get("ctype", "void*")
                if ptype == "const char*":
                    # If payload is NULL, pass empty string to avoid crash
                    wrapper_lines.append(f"    {c_name}_{handler_name}(payload ? (const char*)payload : \"\");")
                elif ptype in ("int32_t", "int"):
                    wrapper_lines.append(f"    {c_name}_{handler_name}((int32_t)(intptr_t)payload);")
                elif ptype == "float":
                    wrapper_lines.append(f"    {c_name}_{handler_name}(payload ? *(float*)payload : 0.0f);")
                else:
                    wrapper_lines.append(f"    {c_name}_{handler_name}(({ptype})payload);")
            else:
                # Multiple parameters - assume payload is a struct pointer
                wrapper_lines.append(f"    (void)payload;  // TODO: unpack struct")
                wrapper_lines.append(f"    // {c_name}_{handler_name}(...);")

            wrapper_lines.append(f"}}")
            signal_wrapper_lines.append("\n".join(wrapper_lines))

    # Build public function implementations
    public_func_lines = []
    for func in public_funcs:
        impl = generate_function_implementation(func, is_static=False)
        public_func_lines.append(impl)

    # Build init body
    init_body_lines = []

    # Allocate tweens first (they were declared as NULL globals)
    for m in members:
        mtype = m.get("ctype", "")
        mname = m.get("name", "")
        if mtype == "ArmTween*":
            init_body_lines.append(f"    {c_name}_{mname} = tween_alloc();")

    init_func = next((f for f in functions if f.get("name") == "init"), None)
    if init_func:
        body = init_func.get("body", [])
        for node in body:
            code = emitter.emit(node)
            if code and code != "":
                for line in code.split('\n'):
                    if line.strip():
                        if not line.strip().endswith((';', '{', '}')):
                            init_body_lines.append(f"    {line};")
                        else:
                            init_body_lines.append(f"    {line}")

    return {
        'name': name,
        'c_name': c_name,
        'order': order,
        'traits_include': traits_include,
        'forward_declarations': '\n'.join(forward_decl_lines),
        'signal_structs': '\n'.join(signal_struct_lines),
        'member_externs': '\n'.join(member_extern_lines),
        'signal_externs': '\n'.join(signal_extern_lines),
        'function_declarations': '\n'.join(func_decl_lines),
        'member_definitions': '\n'.join(member_def_lines + capture_global_lines),
        'signal_definitions': '\n'.join(signal_def_lines),
        'tween_callbacks': '\n\n'.join(tween_callback_lines),
        'private_functions': '\n\n'.join(private_func_lines),
        'signal_wrappers': '\n\n'.join(signal_wrapper_lines),
        'public_functions': '\n\n'.join(public_func_lines),
        'init_body': '\n'.join(init_body_lines),
    }


def prepare_autoload_template_data():
    """Prepare template data for autoload file generation.

    Returns:
        tuple of (list of (c_name, template_data), master_data, features) or ([], None, {}) if no autoloads
        - list contains tuples of (c_name, template_data_dict) for each autoload
        - master_data is dict with 'includes' and 'init_calls' for autoloads.h
        - features is dict with 'has_audio', etc.
    """
    import arm.utils

    build_dir = arm.utils.build_dir()
    data = load_autoloads_json(build_dir)
    autoloads = data.get("autoloads", {})

    if not autoloads:
        return [], None, {}

    # Sort autoloads by order
    sorted_autoloads = sorted(autoloads.items(), key=lambda x: x[1].get("order", 100))
    autoload_data = []
    autoload_names = []
    all_global_signals = set()
    features = {'has_audio': False}

    for name, autoload_ir in sorted_autoloads:
        c_name = autoload_ir.get("c_name", name.lower())
        autoload_names.append(c_name)

        # Collect global signals from this autoload
        meta = autoload_ir.get("meta", {})
        for gs in meta.get("global_signals", []):
            all_global_signals.add(gs)

        # Detect audio usage in functions
        for func in autoload_ir.get("functions", []):
            if _detect_audio_in_nodes(func.get("body", [])):
                features['has_audio'] = True
                break

        # Prepare template data for this autoload
        tmpl_data = _prepare_autoload_template_data(name, autoload_ir)
        autoload_data.append((c_name, tmpl_data))

    # Prepare master autoloads.h data
    master_data = {
        'includes': '\n'.join(f'#include "{c_name}.h"' for c_name in autoload_names),
        'init_calls': '\n'.join(f'    {c_name}_init();' for c_name in autoload_names),
        'global_signals': list(all_global_signals),  # Pass to caller for merging with traits
    }

    return autoload_data, master_data, features


def _detect_audio_in_nodes(nodes: list) -> bool:
    """Recursively detect audio-related IR nodes."""
    for node in nodes:
        if not isinstance(node, dict):
            continue
        node_type = node.get("type", "")
        if node_type.startswith("audio_"):
            return True
        # Check children recursively
        if _detect_audio_in_nodes(node.get("children", [])):
            return True
        if _detect_audio_in_nodes(node.get("args", [])):
            return True
        if _detect_audio_in_nodes(node.get("body", [])):
            return True
    return False
