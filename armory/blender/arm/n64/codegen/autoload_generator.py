"""
Autoload Generator - Generates C code for autoload classes from IR.

This module contains functions for loading autoload JSON data and preparing
template data for autoload headers and source files.
"""

import json
import os
from typing import Dict, List

from arm import log
from arm.n64.codegen.autoload_emitter import AutoloadIREmitter


def load_autoloads_json(build_dir: str = None) -> dict:
    """Load the n64_autoloads.json file generated by the macro."""
    import arm.utils

    if build_dir is None:
        build_dir = arm.utils.build_dir()

    possible_paths = [
        os.path.join(build_dir, "n64_autoloads.json"),
        os.path.join(build_dir, "build", "n64_autoloads.json"),
        os.path.join(build_dir, "debug", "n64_autoloads.json"),
    ]

    for path in possible_paths:
        if os.path.exists(path):
            try:
                with open(path, 'r') as f:
                    data = json.load(f)
                    version = data.get("ir_version", 0)
                    if version != 1:
                        log.warn(f"Expected IR version 1, got {version} in n64_autoloads.json")
                    return data
            except json.JSONDecodeError as e:
                log.error(f"Invalid JSON in {path}: {e}")
            except IOError as e:
                log.error(f"Error reading {path}: {e}")

    return {"ir_version": 0, "autoloads": {}}


def _prepare_autoload_template_data(name: str, autoload_ir: dict) -> dict:
    """Prepare template data for a single autoload.

    Args:
        name: Autoload class name
        autoload_ir: IR dict from macro

    Returns:
        dict with all template placeholders
    """
    c_name = autoload_ir.get("c_name", name.lower())
    order = autoload_ir.get("order", 100)
    members = autoload_ir.get("members", [])
    functions = autoload_ir.get("functions", [])
    meta = autoload_ir.get("meta", {})
    signals = meta.get("signals", [])

    # Create emitter for code generation - use AutoloadIREmitter for proper prefixing
    member_names = [m["name"] for m in members]
    member_types = {m["name"]: m.get("ctype", "int32_t") for m in members}
    function_names = [f["name"] for f in functions]
    emitter = AutoloadIREmitter(name, c_name, member_names, function_names, member_types)

    # Helper to emit default value
    def emit_default_value(default: dict, ctype: str) -> str:
        if default is None:
            if ctype == "float":
                return "0.0f"
            elif ctype in ("int32_t", "int", "uint32_t", "uint8_t"):
                return "0"
            elif ctype == "bool":
                return "false"
            elif ctype == "const char*":
                return '""'
            elif ctype == "ArmSoundHandle":
                return "{-1, 0, -1, 1.0f, true}"  # channel=-1, mix_channel=0, sound_slot=-1, volume=1.0, finished=true
            elif ctype == "ArmTween*":
                return "NULL"  # Tweens allocated in init, not at global scope
            else:
                return "0"
        # For tween_alloc nodes, we return NULL here (allocation happens in init)
        if isinstance(default, dict) and default.get("type") == "tween_alloc":
            return "NULL"
        return emitter.emit(default)

    # Helper to generate function declaration
    def generate_function_declaration(func: dict) -> str:
        return_type = func.get("return_type", "void")
        func_c_name = func.get("c_name", f"{c_name}_{func.get('name', '')}")
        params = func.get("params", [])
        if params:
            param_str = ", ".join(f"{p.get('ctype', 'int32_t')} {p.get('name', '')}" for p in params)
        else:
            param_str = "void"
        return f"{return_type} {func_c_name}({param_str})"

    # Helper to generate function implementation
    def generate_function_implementation(func: dict, is_static: bool = False, maybe_unused: bool = False) -> str:
        decl = generate_function_declaration(func)
        prefix = ""
        if is_static:
            prefix = "static "
        if maybe_unused:
            prefix += "__attribute__((unused)) "
        lines = [f"{prefix}{decl} {{"]

        # Populate param_types for this function so emit_binop can detect string parameters
        params = func.get("params", [])
        emitter.param_types = {p.get("name", ""): p.get("ctype", "int32_t") for p in params}

        body = func.get("body", [])
        for node in body:
            code = emitter.emit(node)
            if code and code != "":
                for line in code.split('\n'):
                    if line.strip():
                        if not line.strip().endswith((';', '{', '}')):
                            lines.append(f"    {line};")
                        else:
                            lines.append(f"    {line}")

        # Clear param_types after processing
        emitter.param_types = {}

        lines.append("}")
        return "\n".join(lines)

    # Helper to find all identifiers in IR nodes
    def find_all_idents(nodes: list) -> set:
        """Find all identifier names referenced in IR nodes."""
        idents = set()
        for node in nodes:
            if node is None:
                continue
            node_type = node.get("type", "")
            if node_type == "ident":
                idents.add(node.get("value", ""))
            # Recurse into all possible children
            for key in ("children", "args", "body", "then", "else"):
                children = node.get(key, [])
                if children:
                    idents.update(find_all_idents(children))
            obj = node.get("object")
            if obj and isinstance(obj, dict):
                idents.update(find_all_idents([obj]))
        return idents

    # Helper to find all tween callbacks in function bodies
    def find_tween_callbacks(nodes: list) -> list:
        """Recursively find all tween callbacks in IR nodes."""
        callbacks = []
        for node in nodes:
            if node is None:
                continue
            node_type = node.get("type", "")
            if node_type in ("tween_float", "tween_vec4", "tween_delay"):
                props = node.get("props", {})
                on_update = props.get("on_update")
                on_done = props.get("on_done")
                if on_update:
                    callbacks.append(on_update)
                if on_done:
                    callbacks.append(on_done)
            # Recurse into children, args, body
            for key in ("children", "args", "body"):
                children = node.get(key, [])
                if children:
                    callbacks.extend(find_tween_callbacks(children))
            # Also recurse into object (for method_call nodes wrapping tweens like .start())
            obj = node.get("object")
            if obj and isinstance(obj, dict):
                callbacks.extend(find_tween_callbacks([obj]))
        return callbacks

    # Helper to generate a tween callback function
    def generate_tween_callback(callback_info: dict) -> str:
        """Generate a static C callback function for a tween."""
        if not callback_info:
            return ""

        cb_name = callback_info.get("callback_name", "")
        cb_type = callback_info.get("callback_type", "")
        body_nodes = callback_info.get("body", [])
        param_name = callback_info.get("param_name") or "v"  # Handle null from JSON
        captures = callback_info.get("captures", [])

        if not cb_name or not body_nodes:
            return ""

        # Build map of captured param names to their capture global names
        # For is_param captures, we use a global variable to store the value
        param_captures = {c["name"]: f"{c_name}_capture_{c['name']}"
                         for c in captures if c.get("is_param", False)}

        lines = []

        if cb_type == "float":
            # Float callback: void name_float(float value, void* obj, void* data)
            lines.append(f"static void {cb_name}_float(float {param_name}, void* obj, void* data) {{")
            lines.append("    (void)obj; (void)data;")
        elif cb_type == "vec4":
            # Vec4 callback: void name_vec4(ArmVec4* value, void* obj, void* data)
            lines.append(f"static void {cb_name}_vec4(ArmVec4* {param_name}, void* obj, void* data) {{")
            lines.append("    (void)obj; (void)data;")
        elif cb_type == "done":
            # Done callback: void name_done(void* obj, void* data)
            lines.append(f"static void {cb_name}_done(void* obj, void* data) {{")
            lines.append("    (void)obj; (void)data;")
        else:
            return ""

        # Create a modified emitter that substitutes captured params with their globals
        class CaptureEmitter:
            def __init__(self, base_emitter, param_captures):
                self.base = base_emitter
                self.param_captures = param_captures

            def emit(self, node):
                if node is None:
                    return ""
                # Intercept ident nodes that are captured params
                if node.get("type") == "ident":
                    name = node.get("value", "")
                    if name in self.param_captures:
                        return self.param_captures[name]
                # For other nodes, recurse but check children too
                return self.emit_with_capture_substitution(node)

            def emit_with_capture_substitution(self, node):
                if node is None:
                    return ""
                node_type = node.get("type", "")

                # For ident nodes, substitute captured params
                if node_type == "ident":
                    name = node.get("value", "")
                    if name in self.param_captures:
                        return self.param_captures[name]
                    return self.base.emit(node)

                # For method_call, handle the object specially
                if node_type == "method_call":
                    obj = node.get("object")
                    method = node.get("method", "")
                    args = node.get("args", [])

                    # Check if object is a captured param
                    if obj and obj.get("type") == "ident":
                        obj_name = obj.get("value", "")
                        if obj_name in self.param_captures:
                            # Substitute the object with the capture global
                            captured_obj = self.param_captures[obj_name]
                            # Emit args
                            arg_strs = [self.emit(a) for a in args]
                            # Handle audio methods
                            if method == "stop":
                                return f"arm_audio_stop(&{captured_obj})"
                            elif method == "play":
                                return f"arm_audio_start(&{captured_obj})"
                            # Fallback
                            return f"{captured_obj}.{method}({', '.join(arg_strs)})"

                # Default: use base emitter
                return self.base.emit(node)

        capture_emitter = CaptureEmitter(emitter, param_captures) if param_captures else emitter

        # Emit body
        for node in body_nodes:
            code = capture_emitter.emit(node)
            if code and code != "":
                for line in code.split('\n'):
                    if line.strip():
                        if not line.strip().endswith((';', '{', '}')):
                            lines.append(f"    {line};")
                        else:
                            lines.append(f"    {line}")

        lines.append("}")
        return "\n".join(lines)

    # Collect all tween callbacks from all functions, along with function param info
    all_tween_callbacks = []
    # Map from callback_name to list of captured function params (name, ctype)
    callback_param_captures = {}

    for func in functions:
        body = func.get("body", [])
        func_params = {p.get("name"): p.get("ctype", "int32_t") for p in func.get("params", [])}
        found = find_tween_callbacks(body)

        # For each callback, check if any idents match function params
        for cb in found:
            cb_name = cb.get("callback_name", "")
            cb_body = cb.get("body", [])
            idents = find_all_idents(cb_body)

            # Find which idents are function params (not members, not callback param)
            cb_param_name = cb.get("param_name") or ""
            param_caps = []
            for ident_name in idents:
                if ident_name in func_params and ident_name != cb_param_name:
                    if ident_name not in member_names:  # Not a class member
                        param_caps.append((ident_name, func_params[ident_name]))

            if param_caps:
                # Store in the callback's captures
                existing_captures = cb.get("captures", [])
                for pname, pctype in param_caps:
                    existing_captures.append({
                        "name": pname,
                        "type": pctype,
                        "is_member": False,
                        "is_param": True,
                        "ctype": pctype
                    })
                cb["captures"] = existing_captures
                callback_param_captures[cb_name] = param_caps

            all_tween_callbacks.append(cb)

    # Generate capture globals for function params
    capture_global_lines = []
    seen_capture_globals = set()
    for cb_name, param_caps in callback_param_captures.items():
        for pname, pctype in param_caps:
            global_name = f"{c_name}_capture_{pname}"
            if global_name not in seen_capture_globals:
                seen_capture_globals.add(global_name)
                capture_global_lines.append(f"static {pctype} {global_name};")

    # Generate tween callback functions (deduplicated by name)
    tween_callback_lines = []
    seen_callbacks = set()
    for cb in all_tween_callbacks:
        cb_name = cb.get("callback_name", "")
        if cb_name and cb_name not in seen_callbacks:
            seen_callbacks.add(cb_name)
            cb_code = generate_tween_callback(cb)
            if cb_code:
                tween_callback_lines.append(cb_code)

    # Build signal structs
    signal_struct_lines = []
    for sig in signals:
        struct_def = sig.get("struct_def")
        if struct_def:
            signal_struct_lines.append(struct_def)

    # Build member externs (for header)
    member_extern_lines = []
    if members:
        member_extern_lines.append(f"// {name} members")
        for m in members:
            ctype = m.get("ctype", "int32_t")
            mname = m.get("name", "")
            member_extern_lines.append(f"extern {ctype} {c_name}_{mname};")

    # Build signal externs (for header)
    signal_extern_lines = []
    if signals:
        signal_extern_lines.append(f"// {name} signals")
        for sig in signals:
            sig_name = sig.get("name", "")
            signal_extern_lines.append(f"extern ArmSignal {c_name}_{sig_name};")

    # Build function declarations (public only, for header)
    func_decl_lines = []
    public_funcs = [f for f in functions if f.get("is_public", False) and f.get("name") != "init"]
    if public_funcs:
        func_decl_lines.append(f"// {name} public functions")
        for func in public_funcs:
            decl = generate_function_declaration(func)
            func_decl_lines.append(f"{decl};")

    # Build member definitions (for source)
    member_def_lines = []
    if members:
        member_def_lines.append(f"// {name} members")
        for m in members:
            ctype = m.get("ctype", "int32_t")
            mname = m.get("name", "")
            default = m.get("default_value")
            init_value = emit_default_value(default, ctype)
            member_def_lines.append(f"{ctype} {c_name}_{mname} = {init_value};")

    # Build signal definitions (for source)
    signal_def_lines = []
    if signals:
        signal_def_lines.append(f"// {name} signals")
        for sig in signals:
            sig_name = sig.get("name", "")
            signal_def_lines.append(f"ArmSignal {c_name}_{sig_name} = {{0}};")

    # Build private function implementations
    private_func_lines = []
    private_funcs = [f for f in functions if not f.get("is_public", False) and f.get("name") != "init"]
    for func in private_funcs:
        # Mark as maybe_unused since setters might not be called externally
        impl = generate_function_implementation(func, is_static=True, maybe_unused=True)
        private_func_lines.append(impl)

    # Build signal handler wrappers
    # When a function is connected to a signal, we need a wrapper with the correct signature
    signal_handlers = meta.get("signal_handlers", [])
    signal_wrapper_lines = []
    for sh in signal_handlers:
        handler_name = sh.get("handler_name", "")
        if handler_name:
            # Find the function to get its parameters
            handler_func = next((f for f in functions if f["name"] == handler_name), None)
            params = handler_func.get("params", []) if handler_func else []

            # Generate wrapper that calls the actual function
            # Wrapper has ArmSignalHandler signature: void (*)(void* ctx, void* payload)
            wrapper_lines = [
                f"static void {c_name}_{handler_name}_wrapper(void* ctx, void* payload) {{",
                f"    (void)ctx;",
            ]

            if not params:
                # No parameters - just suppress payload warning and call
                wrapper_lines.append(f"    (void)payload;")
                wrapper_lines.append(f"    {c_name}_{handler_name}();")
            elif len(params) == 1:
                # Single parameter - check if signal provides this or if it's ignored
                # For signals like sceneLoaded that send const char*, cast payload
                p = params[0]
                ptype = p.get("ctype", "void*")
                if ptype == "const char*":
                    # If payload is NULL, pass empty string to avoid crash
                    wrapper_lines.append(f"    {c_name}_{handler_name}(payload ? (const char*)payload : \"\");")
                elif ptype in ("int32_t", "int"):
                    wrapper_lines.append(f"    {c_name}_{handler_name}((int32_t)(intptr_t)payload);")
                elif ptype == "float":
                    wrapper_lines.append(f"    {c_name}_{handler_name}(payload ? *(float*)payload : 0.0f);")
                else:
                    wrapper_lines.append(f"    {c_name}_{handler_name}(({ptype})payload);")
            else:
                # Multiple parameters - assume payload is a struct pointer
                wrapper_lines.append(f"    (void)payload;  // TODO: unpack struct")
                wrapper_lines.append(f"    // {c_name}_{handler_name}(...);")

            wrapper_lines.append(f"}}")
            signal_wrapper_lines.append("\n".join(wrapper_lines))

    # Build public function implementations
    public_func_lines = []
    for func in public_funcs:
        impl = generate_function_implementation(func, is_static=False)
        public_func_lines.append(impl)

    # Build init body
    init_body_lines = []

    # Allocate tweens first (they were declared as NULL globals)
    for m in members:
        mtype = m.get("ctype", "")
        mname = m.get("name", "")
        if mtype == "ArmTween*":
            init_body_lines.append(f"    {c_name}_{mname} = tween_alloc();")

    init_func = next((f for f in functions if f.get("name") == "init"), None)
    if init_func:
        body = init_func.get("body", [])
        for node in body:
            code = emitter.emit(node)
            if code and code != "":
                for line in code.split('\n'):
                    if line.strip():
                        if not line.strip().endswith((';', '{', '}')):
                            init_body_lines.append(f"    {line};")
                        else:
                            init_body_lines.append(f"    {line}")

    return {
        'name': name,
        'c_name': c_name,
        'order': order,
        'signal_structs': '\n'.join(signal_struct_lines),
        'member_externs': '\n'.join(member_extern_lines),
        'signal_externs': '\n'.join(signal_extern_lines),
        'function_declarations': '\n'.join(func_decl_lines),
        'member_definitions': '\n'.join(member_def_lines + capture_global_lines),
        'signal_definitions': '\n'.join(signal_def_lines),
        'tween_callbacks': '\n\n'.join(tween_callback_lines),
        'private_functions': '\n\n'.join(private_func_lines),
        'signal_wrappers': '\n\n'.join(signal_wrapper_lines),
        'public_functions': '\n\n'.join(public_func_lines),
        'init_body': '\n'.join(init_body_lines),
    }


def prepare_autoload_template_data():
    """Prepare template data for autoload file generation.

    Returns:
        tuple of (list of (c_name, template_data), master_data, features) or ([], None, {}) if no autoloads
        - list contains tuples of (c_name, template_data_dict) for each autoload
        - master_data is dict with 'includes' and 'init_calls' for autoloads.h
        - features is dict with 'has_audio', etc.
    """
    import arm.utils

    build_dir = arm.utils.build_dir()
    data = load_autoloads_json(build_dir)
    autoloads = data.get("autoloads", {})

    if not autoloads:
        return [], None, {}

    # Sort autoloads by order
    sorted_autoloads = sorted(autoloads.items(), key=lambda x: x[1].get("order", 100))
    autoload_data = []
    autoload_names = []
    all_global_signals = set()
    features = {'has_audio': False}

    for name, autoload_ir in sorted_autoloads:
        c_name = autoload_ir.get("c_name", name.lower())
        autoload_names.append(c_name)

        # Collect global signals from this autoload
        meta = autoload_ir.get("meta", {})
        for gs in meta.get("global_signals", []):
            all_global_signals.add(gs)

        # Detect audio usage in functions
        for func in autoload_ir.get("functions", []):
            if _detect_audio_in_nodes(func.get("body", [])):
                features['has_audio'] = True
                break

        # Prepare template data for this autoload
        tmpl_data = _prepare_autoload_template_data(name, autoload_ir)
        autoload_data.append((c_name, tmpl_data))

    # Prepare master autoloads.h data
    master_data = {
        'includes': '\n'.join(f'#include "{c_name}.h"' for c_name in autoload_names),
        'init_calls': '\n'.join(f'    {c_name}_init();' for c_name in autoload_names),
        'global_signals': list(all_global_signals),  # Pass to caller for merging with traits
    }

    return autoload_data, master_data, features


def _detect_audio_in_nodes(nodes: list) -> bool:
    """Recursively detect audio-related IR nodes."""
    for node in nodes:
        if not isinstance(node, dict):
            continue
        node_type = node.get("type", "")
        if node_type.startswith("audio_"):
            return True
        # Check children recursively
        if _detect_audio_in_nodes(node.get("children", [])):
            return True
        if _detect_audio_in_nodes(node.get("args", [])):
            return True
        if _detect_audio_in_nodes(node.get("body", [])):
            return True
    return False
