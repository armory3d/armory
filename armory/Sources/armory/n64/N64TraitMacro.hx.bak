package armory.n64;

#if macro
import haxe.macro.Context;
import haxe.macro.Expr;
import haxe.macro.Type;
import haxe.Json;
import sys.io.File;
import sys.FileSystem;

using haxe.macro.ExprTools;
using haxe.macro.TypeTools;
using StringTools;
using Lambda;

// Import IR types
import armory.n64.N64IR;
import armory.n64.N64Config;

/**
 * N64 Trait Macro - Extracts trait logic and converts to IR.
 *
 * Pipeline: Haxe AST → IR nodes → JSON → Python → C code
 *
 * This macro does NOT generate C code - it produces semantic IR nodes
 * that describe WHAT the trait does, not HOW to implement it.
 */
class N64TraitMacro {
    static var traitData:Map<String, TraitIR> = new Map();
    static var initialized:Bool = false;

    macro public static function build():Array<Field> {
        var defines = Context.getDefines();
        if (!defines.exists("arm_target_n64")) {
            return null;
        }

        if (!initialized) {
            initialized = true;
            Context.onAfterTyping(function(_) {
                writeTraitJson();
            });
        }

        var localClass = Context.getLocalClass();
        if (localClass == null) return null;

        var cls = localClass.get();
        var className = cls.name;
        var modulePath = cls.module;

        // Skip internal/engine traits
        if (modulePath.indexOf("iron.") == 0 || modulePath.indexOf("armory.") == 0) {
            return null;
        }

        var fields = Context.getBuildFields();

        // Extract trait IR
        var extractor = new TraitExtractor(className, fields);
        var traitIR = extractor.extract();

        if (traitIR != null) {
            traitData.set(className, traitIR);
        }

        return null;
    }

    static function writeTraitJson():Void {
        if (traitData.keys().hasNext() == false) return;

        var traits:Array<Dynamic> = [];
        var allButtons:Array<String> = [];
        var anyTransform = false;
        var anyScene = false;
        var sceneNames:Array<String> = [];

        for (name in traitData.keys()) {
            var ir = traitData.get(name);

            // Skip empty traits
            var hasCode = ir.init.length > 0 || ir.fixedUpdate.length > 0 ||
                          ir.update.length > 0 || ir.remove.length > 0 ||
                          Lambda.count(ir.events) > 0;
            if (!hasCode && !ir.needsData) continue;

            // Convert members map to JSON object
            var membersObj:Dynamic = {};
            for (memberName in ir.members.keys()) {
                var m = ir.members.get(memberName);
                Reflect.setField(membersObj, memberName, {
                    type: m.haxeType,
                    default_value: serializeIRNode(m.defaultValue)
                });
            }

            // Convert events map to JSON object
            var eventsObj:Dynamic = {};
            for (eventName in ir.events.keys()) {
                var eventNodes = ir.events.get(eventName);
                Reflect.setField(eventsObj, eventName, [for (n in eventNodes) serializeIRNode(n)]);
            }

            traits.push({
                name: ir.name,
                skip: !hasCode && !ir.needsData,
                needs_data: ir.needsData,
                members: membersObj,
                init: [for (n in ir.init) serializeIRNode(n)],
                fixed_update: [for (n in ir.fixedUpdate) serializeIRNode(n)],
                update: [for (n in ir.update) serializeIRNode(n)],
                remove: [for (n in ir.remove) serializeIRNode(n)],
                events: eventsObj,
                flags: ir.flags,
                input_buttons: ir.inputButtons
            });

            // Aggregate summary
            for (btn in ir.inputButtons) {
                if (!Lambda.has(allButtons, btn)) allButtons.push(btn);
            }
            anyTransform = anyTransform || ir.flags.has_transform;
            anyScene = anyScene || ir.flags.has_scene;
            if (ir.targetScene != null && !Lambda.has(sceneNames, ir.targetScene)) {
                sceneNames.push(ir.targetScene);
            }
        }

        var output:Dynamic = {
            version: 6,  // New IR-based format
            generated: "N64TraitMacro",
            format: "ir",  // Indicates this is IR, not C code
            traits: traits,
            summary: {
                input_buttons: allButtons,
                has_transform: anyTransform,
                has_scene: anyScene,
                scene_names: sceneNames
            }
        };

        var json = Json.stringify(output, null, "  ");

        var defines = Context.getDefines();
        var buildDir = defines.get("arm_build_dir");
        if (buildDir == null) buildDir = "build";

        var outPath = buildDir + "/n64_traits.json";
        try {
            var dir = haxe.io.Path.directory(outPath);
            if (dir != "" && !FileSystem.exists(dir)) {
                FileSystem.createDirectory(dir);
            }
            File.saveContent(outPath, json);
        } catch (e:Dynamic) {
            Context.error('Failed to write n64_traits.json: $e', Context.currentPos());
        }
    }

    /** Serialize an IR node to a JSON-compatible Dynamic */
    static function serializeIRNode(node:IRNode):Dynamic {
        if (node == null) return null;

        var obj:Dynamic = { type: node.type };

        if (node.value != null) obj.value = node.value;
        if (node.children != null && node.children.length > 0) {
            obj.children = [for (c in node.children) serializeIRNode(c)];
        }
        if (node.props != null) obj.props = node.props;

        return obj;
    }
}

/**
 * Trait Extractor - converts Haxe AST to IR nodes
 */
class TraitExtractor {
    var className:String;
    var fields:Array<Field>;
    var members:Map<String, MemberIR>;
    var memberNames:Array<String>;
    var methodMap:Map<String, Function>;
    var localVars:Map<String, Bool>;
    var inputButtons:Array<String>;
    var flags:TraitFlags;
    var targetScene:String;

    public function new(className:String, fields:Array<Field>) {
        this.className = className;
        this.fields = fields;
        this.members = new Map();
        this.memberNames = [];
        this.methodMap = new Map();
        this.localVars = new Map();
        this.inputButtons = [];
        this.flags = { needs_obj: false, needs_dt: false, has_transform: false, has_scene: false };
        this.targetScene = null;
    }

    public function extract():TraitIR {
        // Pass 1: Extract members and methods
        for (field in fields) {
            switch (field.kind) {
                case FVar(t, e):
                    var member = extractMember(field.name, t, e, field.meta);
                    if (member != null) {
                        members.set(field.name, member);
                        memberNames.push(field.name);
                    }
                case FFun(func):
                    methodMap.set(field.name, func);
                default:
            }
        }

        // Pass 2: Find lifecycle registrations
        var lifecycles = findLifecycles();

        // Pass 3: Convert lifecycle functions to IR
        var initIR:Array<IRNode> = [];
        var fixedUpdateIR:Array<IRNode> = [];
        var updateIR:Array<IRNode> = [];
        var removeIR:Array<IRNode> = [];
        var events:Map<String, Array<IRNode>> = new Map();

        if (lifecycles.init != null) {
            var result = convertToIR(lifecycles.init);
            initIR = result.statements;
            mergeEvents(events, result.events);
        }
        if (lifecycles.fixed_update != null) {
            var result = convertToIR(lifecycles.fixed_update);
            fixedUpdateIR = result.statements;
            mergeEvents(events, result.events);
        }
        if (lifecycles.update != null) {
            var result = convertToIR(lifecycles.update);
            updateIR = result.statements;
            mergeEvents(events, result.events);
        }
        if (lifecycles.remove != null) {
            var result = convertToIR(lifecycles.remove);
            removeIR = result.statements;
            mergeEvents(events, result.events);
        }

        return {
            name: className,
            needsData: memberNames.length > 0,
            members: members,
            init: initIR,
            fixedUpdate: fixedUpdateIR,
            update: updateIR,
            remove: removeIR,
            events: events,
            flags: flags,
            inputButtons: inputButtons,
            targetScene: targetScene
        };
    }

    function mergeEvents(target:Map<String, Array<IRNode>>, source:Map<String, Array<IRNode>>):Void {
        for (key in source.keys()) {
            if (!target.exists(key)) target.set(key, []);
            for (node in source.get(key)) {
                target.get(key).push(node);
            }
        }
    }

    function extractMember(name:String, t:ComplexType, e:Expr, meta:Metadata):MemberIR {
        // Skip API objects
        if (N64Config.shouldSkipMember(name)) return null;

        var typeName = t != null ? complexTypeToString(t) : "Dynamic";
        if (!N64Config.isSupportedType(typeName)) return null;

        var defaultNode:IRNode = null;
        if (e != null) {
            // For SceneId type, convert identifier to SCENE_XXX string literal
            if (typeName == "SceneId") {
                switch (e.expr) {
                    case EConst(CIdent(sceneName)):
                        // Convert scene identifier to SCENE_XXX enum string
                        var enumName = "SCENE_" + sceneName.toUpperCase();
                        defaultNode = IRBuilder.stringLit(enumName);
                    default:
                        defaultNode = exprToIR(e);
                }
            } else {
                defaultNode = exprToIR(e);
            }
        }

        return {
            haxeType: typeName,
            defaultValue: defaultNode
        };
    }

    function complexTypeToString(ct:ComplexType):String {
        return switch (ct) {
            case TPath(p): p.name;
            default: "Dynamic";
        };
    }

    function findLifecycles():{init:Expr, fixed_update:Expr, update:Expr, remove:Expr} {
        var result = {init: null, fixed_update: null, update: null, remove: null};
        var constructor = methodMap.get("new");
        if (constructor != null && constructor.expr != null) {
            scanForLifecycles(constructor.expr, result);
        }
        return result;
    }

    function scanForLifecycles(e:Expr, result:{init:Expr, fixed_update:Expr, update:Expr, remove:Expr}):Void {
        if (e == null) return;

        switch (e.expr) {
            case ECall(callExpr, params):
                var funcName = getFuncName(callExpr);
                if (params.length > 0) {
                    var body = resolveCallback(params[0]);
                    switch (funcName) {
                        case "notifyOnInit": result.init = body;
                        case "notifyOnFixedUpdate": result.fixed_update = body;
                        case "notifyOnUpdate": result.update = body;
                        case "notifyOnRemove": result.remove = body;
                        default:
                    }
                }
                for (p in params) scanForLifecycles(p, result);
            case EBlock(exprs):
                for (expr in exprs) scanForLifecycles(expr, result);
            case EIf(_, eif, eelse):
                scanForLifecycles(eif, result);
                if (eelse != null) scanForLifecycles(eelse, result);
            case EFunction(_, f):
                return;  // Don't recurse into nested functions
            default:
                e.iter(function(sub) scanForLifecycles(sub, result));
        }
    }

    function getFuncName(e:Expr):String {
        return switch (e.expr) {
            case EConst(CIdent(s)): s;
            case EField(_, field): field;
            default: null;
        };
    }

    function resolveCallback(e:Expr):Expr {
        return switch (e.expr) {
            case EFunction(_, f): f.expr;
            case EField(_, methodName):
                var method = methodMap.get(methodName);
                method != null ? method.expr : null;
            case EConst(CIdent(methodName)):
                var method = methodMap.get(methodName);
                method != null ? method.expr : null;
            default: null;
        };
    }

    /** Convert a Haxe expression block to IR nodes */
    function convertToIR(body:Expr):{statements:Array<IRNode>, events:Map<String, Array<IRNode>>} {
        var statements:Array<IRNode> = [];
        var events:Map<String, Array<IRNode>> = new Map();

        switch (body.expr) {
            case EBlock(exprs):
                for (expr in exprs) {
                    var result = convertExprToIR(expr);
                    if (result.node != null) statements.push(result.node);
                    mergeEvents(events, result.events);
                }
            default:
                var result = convertExprToIR(body);
                if (result.node != null) statements.push(result.node);
                mergeEvents(events, result.events);
        }

        return {statements: statements, events: events};
    }

    /** Convert a single expression to IR, potentially extracting events */
    function convertExprToIR(e:Expr):{node:IRNode, events:Map<String, Array<IRNode>>} {
        var events:Map<String, Array<IRNode>> = new Map();

        if (e == null) return {node: null, events: events};

        switch (e.expr) {
            // Check for input event patterns: if (gamepad.started("a")) { ... }
            case EIf(econd, eif, eelse):
                var eventInfo = detectInputEvent(econd);
                if (eventInfo != null && eelse == null) {
                    // Extract as event handler
                    var bodyResult = convertToIR(eif);
                    if (!events.exists(eventInfo.eventName)) {
                        events.set(eventInfo.eventName, []);
                    }
                    for (stmt in bodyResult.statements) {
                        events.get(eventInfo.eventName).push(stmt);
                    }
                    // Track button usage
                    if (!Lambda.has(inputButtons, eventInfo.button)) {
                        inputButtons.push(eventInfo.button);
                    }
                    return {node: null, events: events};  // Extracted, no node in main flow
                }
                // Regular if statement
                var condNode = exprToIR(econd);
                var thenResult = convertToIR(eif);
                var elseResult = eelse != null ? convertToIR(eelse) : null;

                mergeEvents(events, thenResult.events);
                if (elseResult != null) mergeEvents(events, elseResult.events);

                var node = IRBuilder.ifStmt(condNode, thenResult.statements,
                    elseResult != null ? elseResult.statements : null);
                return {node: node, events: events};

            case EWhile(econd, body, normalWhile):
                var condNode = exprToIR(econd);
                var bodyResult = convertToIR(body);
                mergeEvents(events, bodyResult.events);
                var node = IRBuilder.whileLoop(condNode, bodyResult.statements);
                if (!normalWhile) node.props.doWhile = true;
                return {node: node, events: events};

            case EFor(it, body):
                var forNode = convertForLoop(it, body);
                return {node: forNode, events: events};

            case EBlock(exprs):
                var stmts:Array<IRNode> = [];
                for (expr in exprs) {
                    var result = convertExprToIR(expr);
                    if (result.node != null) stmts.push(result.node);
                    mergeEvents(events, result.events);
                }
                return {node: IRBuilder.block(stmts), events: events};

            default:
                return {node: exprToIR(e), events: events};
        }
    }

    /** Detect if condition is a simple input event check */
    function detectInputEvent(econd:Expr):{eventName:String, button:String, method:String} {
        switch (econd.expr) {
            case ECall(e, params):
                switch (e.expr) {
                    case EField(obj, method):
                        switch (obj.expr) {
                            case EConst(CIdent("gamepad")):
                                if (method == "started" || method == "released" || method == "down") {
                                    if (params.length > 0) {
                                        var button = extractButtonName(params[0]);
                                        if (button != null) {
                                            var btnName = button.toLowerCase();
                                            var eventName = 'btn_${btnName}_$method';
                                            return {eventName: eventName, button: button, method: method};
                                        }
                                    }
                                }
                            default:
                        }
                    default:
                }
            default:
        }
        return null;
    }

    function extractButtonName(e:Expr):String {
        return switch (e.expr) {
            case EConst(CString(s)): s;
            case EConst(CIdent(s)): s;
            case EField(_, field): field;
            default: null;
        };
    }

    function convertForLoop(it:Expr, body:Expr):IRNode {
        switch (it.expr) {
            case EBinop(OpInterval, startExpr, endExpr):
                var bodyResult = convertToIR(body);
                return IRBuilder.forLoop("i", exprToIR(startExpr), exprToIR(endExpr), bodyResult.statements);
            default:
                Context.warning('N64: Complex for-loop not supported', it.pos);
                return null;
        }
    }

    /** Convert a Haxe expression to an IR node (no event extraction) */
    function exprToIR(e:Expr):IRNode {
        if (e == null) return null;

        return switch (e.expr) {
            // Literals
            case EConst(CInt(v)): IRBuilder.intLit(Std.parseInt(v));
            case EConst(CFloat(v)): IRBuilder.floatLit(Std.parseFloat(v));
            case EConst(CString(v)): IRBuilder.stringLit(v);
            case EConst(CIdent("true")): IRBuilder.boolLit(true);
            case EConst(CIdent("false")): IRBuilder.boolLit(false);
            case EConst(CIdent("null")): IRBuilder.nullLit();
            case EConst(CIdent(name)): resolveIdent(name);

            // Binary operations
            case EBinop(op, e1, e2):
                var opStr = binopToString(op);
                if (isAssignOp(op) && opStr == "=") {
                    // Check for transform property assignment
                    var transformAssign = tryConvertTransformAssign(e1, e2);
                    if (transformAssign != null) {
                        transformAssign;
                    } else {
                        IRBuilder.assignOp(opStr, exprToIR(e1), exprToIR(e2));
                    }
                } else if (isAssignOp(op)) {
                    IRBuilder.assignOp(opStr, exprToIR(e1), exprToIR(e2));
                } else {
                    IRBuilder.binop(opStr, exprToIR(e1), exprToIR(e2));
                }

            // Unary operations
            case EUnop(op, postFix, operand):
                IRBuilder.unop(unopToString(op), exprToIR(operand), postFix);

            // Field access
            case EField(obj, field):
                convertFieldAccess(obj, field);

            // Function calls
            case ECall(callExpr, params):
                convertCall(callExpr, params);

            // Parentheses
            case EParenthesis(inner):
                exprToIR(inner);

            // Array access
            case EArray(arr, index):
                IRBuilder.binop("[]", exprToIR(arr), exprToIR(index));

            // New object
            case ENew(tp, params):
                convertNew(tp.name, params);

            // Block
            case EBlock(exprs):
                IRBuilder.block([for (expr in exprs) exprToIR(expr)]);

            // Ternary
            case ETernary(econd, eif, eelse):
                IRBuilder.ifStmt(exprToIR(econd), [exprToIR(eif)], [exprToIR(eelse)]);

            default:
                Context.warning('N64: Unsupported expression type', e.pos);
                null;
        };
    }

    function resolveIdent(name:String):IRNode {
        // Check if it's a known identifier
        if (name == "this" || name == "object") {
            flags.needs_obj = true;
            return IRBuilder.param("obj");
        }
        if (name == "dt") {
            flags.needs_dt = true;
            return IRBuilder.param("dt");
        }
        if (memberNames.indexOf(name) >= 0) {
            return IRBuilder.member(name);
        }
        if (localVars.exists(name)) {
            return IRBuilder.local(name);
        }
        // Skip unsupported API identifiers (physics, gamepad, keyboard, etc.)
        if (N64Config.shouldSkipMember(name)) {
            return IRBuilder.skip();
        }
        // Skip unsupported class identifiers (PhysicsWorld, RigidBody, etc.)
        if (N64Config.isUnsupportedClass(name)) {
            return IRBuilder.skip();
        }
        // Assume it's a local variable
        return IRBuilder.local(name);
    }

    function convertFieldAccess(obj:Expr, field:String):IRNode {
        // Handle transform access
        switch (obj.expr) {
            case EField(innerObj, innerField):
                if (innerField == "transform") {
                    flags.needs_obj = true;
                    flags.has_transform = true;
                    return convertTransformAccess(field);
                }
            case EConst(CIdent("transform")):
                flags.needs_obj = true;
                flags.has_transform = true;
                return convertTransformAccess(field);
            case EConst(CIdent("gamepad")):
                return convertGamepadAccess(field);
            default:
        }

        // Check for Vec3 component access (x, y, z) on any expression
        if (field == "x" || field == "y" || field == "z") {
            return IRBuilder.vec3Component(exprToIR(obj), field);
        }

        // Generic field access
        return { type: "FieldAccess", value: field, children: [exprToIR(obj)] };
    }

    function convertTransformAccess(field:String):IRNode {
        return switch (field) {
            case "loc", "location", "position": IRBuilder.transformGetLoc();
            case "rot", "rotation": IRBuilder.transformGetRot();
            case "scale": IRBuilder.transformGetScale();
            default: { type: "TransformField", value: field };
        };
    }

    function tryConvertTransformAssign(target:Expr, value:Expr):Null<IRNode> {
        // Check if target is transform.property
        switch (target.expr) {
            case EField(obj, field):
                switch (obj.expr) {
                    case EField(innerObj, "transform"):
                        // This is something.transform.field = value
                        flags.needs_obj = true;
                        flags.has_transform = true;
                        return convertTransformPropertyAssign(field, value);
                    case EConst(CIdent("transform")):
                        // This is transform.field = value (implicit this.transform)
                        flags.needs_obj = true;
                        flags.has_transform = true;
                        return convertTransformPropertyAssign(field, value);
                    default:
                }
            default:
        }
        return null;
    }

    function convertTransformPropertyAssign(field:String, value:Expr):IRNode {
        // Convert Vec3/Vec4 value to components for Set* IR nodes (swizzling done in IRBuilder)
        return switch (field) {
            case "loc", "location", "position":
                switch (value.expr) {
                    case ENew(tp, params) if (tp.name == "Vec4" || tp.name == "Vec3"):
                        if (params.length >= 3) {
                            IRBuilder.transformSetLoc(exprToIR(params[0]), exprToIR(params[1]), exprToIR(params[2]));
                        } else {
                            IRBuilder.skip();
                        }
                    default:
                        IRBuilder.skip();
                }
            case "rot", "rotation":
                switch (value.expr) {
                    case ENew(tp, params) if (tp.name == "Vec4" || tp.name == "Quat"):
                        if (params.length >= 4) {
                            IRBuilder.transformSetRot(exprToIR(params[0]), exprToIR(params[1]), exprToIR(params[2]), exprToIR(params[3]));
                        } else if (params.length >= 3) {
                            IRBuilder.transformSetRot(exprToIR(params[0]), exprToIR(params[1]), exprToIR(params[2]), IRBuilder.floatLit(1.0));
                        } else {
                            IRBuilder.skip();
                        }
                    default:
                        IRBuilder.skip();
                }
            case "scale":
                switch (value.expr) {
                    case ENew(tp, params) if (tp.name == "Vec4" || tp.name == "Vec3"):
                        if (params.length >= 3) {
                            IRBuilder.transformSetScale(exprToIR(params[0]), exprToIR(params[1]), exprToIR(params[2]));
                        } else {
                            IRBuilder.skip();
                        }
                    default:
                        IRBuilder.skip();
                }
            default:
                IRBuilder.skip();
        };
    }

    function convertGamepadAccess(field:String):IRNode {
        return switch (field) {
            case "leftStick", "rightStick": IRBuilder.skip();
            default: IRBuilder.skip();
        };
    }

    function convertCall(callExpr:Expr, params:Array<Expr>):IRNode {
        var args = [for (p in params) exprToIR(p)];

        switch (callExpr.expr) {
            case EField(obj, method):
                // Check for known patterns
                switch (obj.expr) {
                    case EConst(CIdent("gamepad")):
                        return convertGamepadCall(method, args, params);
                    case EConst(CIdent("Math")):
                        return IRBuilder.mathCall(method, args);
                    case EField(innerObj, "transform"):
                        flags.needs_obj = true;
                        flags.has_transform = true;
                        return convertTransformCall(method, args);
                    case EConst(CIdent("Scene")):
                        flags.has_scene = true;
                        return convertSceneCall(method, args, params);
                    default:
                }
                // Generic method call
                return { type: "MethodCall", value: method, children: [exprToIR(obj)].concat(args) };

            case EConst(CIdent(funcName)):
                return IRBuilder.funcCall(funcName, args);

            default:
                return IRBuilder.funcCall("unknown", args);
        }
    }

    function convertGamepadCall(method:String, args:Array<IRNode>, params:Array<Expr>):IRNode {
        var button = params.length > 0 ? extractButtonName(params[0]) : "a";
        if (!Lambda.has(inputButtons, button)) inputButtons.push(button);

        return switch (method) {
            case "down": IRBuilder.inputDown(button);
            case "started": IRBuilder.inputStarted(button);
            case "released": IRBuilder.inputReleased(button);
            case "getStickX": IRBuilder.inputStickX();
            case "getStickY": IRBuilder.inputStickY();
            default: IRBuilder.skip();
        };
    }

    function convertTransformCall(method:String, args:Array<IRNode>):IRNode {
        return switch (method) {
            case "translate", "move":
                if (args.length >= 3) IRBuilder.transformTranslate(args[0], args[1], args[2]);
                else IRBuilder.skip();
            case "rotate":
                if (args.length >= 4) IRBuilder.transformRotateVec(args[0], args[1], args[2], args[3]);
                else IRBuilder.skip();
            default:
                IRBuilder.skip();
        };
    }

    function convertSceneCall(method:String, args:Array<IRNode>, params:Array<Expr>):IRNode {
        if (method == "setActive" && params.length > 0) {
            // Check if it's a string literal
            var sceneName = extractSceneName(params[0]);
            if (sceneName != null) {
                targetScene = sceneName;
                return IRBuilder.sceneSet(sceneName);
            }

            // Check if it's a member variable - upgrade its type to SceneId
            var memberName = extractMemberName(params[0]);
            if (memberName != null && members.exists(memberName)) {
                var member = members.get(memberName);
                // Upgrade String type to SceneId
                member.haxeType = "SceneId";
                flags.has_scene = true;
                return IRBuilder.sceneSetMember(memberName);
            }
        }
        return IRBuilder.skip();
    }

    function extractMemberName(e:Expr):String {
        return switch (e.expr) {
            case EConst(CIdent(name)): name;
            case EField(_, field): field;
            default: null;
        };
    }

    function extractSceneName(e:Expr):String {
        return switch (e.expr) {
            case EConst(CString(s)): s;
            default: null;
        };
    }

    function convertNew(typeName:String, params:Array<Expr>):IRNode {
        var args = [for (p in params) exprToIR(p)];

        if ((typeName == "Vec4" || typeName == "Vec3") && args.length >= 3) {
            return IRBuilder.vec3(args[0], args[1], args[2]);
        }

        return { type: "New", value: typeName, children: args };
    }

    function binopToString(op:Binop):String {
        return switch (op) {
            case OpAdd: "+";
            case OpSub: "-";
            case OpMult: "*";
            case OpDiv: "/";
            case OpMod: "%";
            case OpEq: "==";
            case OpNotEq: "!=";
            case OpLt: "<";
            case OpLte: "<=";
            case OpGt: ">";
            case OpGte: ">=";
            case OpAnd: "&&";
            case OpOr: "||";
            case OpAssign: "=";
            case OpAssignOp(op): binopToString(op) + "=";
            default: "?";
        };
    }

    function unopToString(op:Unop):String {
        return switch (op) {
            case OpNeg: "-";
            case OpNot: "!";
            case OpIncrement: "++";
            case OpDecrement: "--";
            default: "?";
        };
    }

    function isAssignOp(op:Binop):Bool {
        return switch (op) {
            case OpAssign, OpAssignOp(_): true;
            default: false;
        };
    }
}
#end
